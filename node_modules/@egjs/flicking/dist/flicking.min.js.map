{"version":3,"file":"flicking.min.js","sources":["../src/const/error.ts","../src/control/states/State.ts","../src/const/external.ts","../src/utils.ts","../src/core/FlickingError.ts","../src/core/Viewport.ts","../src/core/AutoResizer.ts","../src/core/panel/provider/VanillaElementProvider.ts","../src/core/panel/provider/VirtualElementProvider.ts","../src/core/VirtualManager.ts","../src/const/axes.ts","../src/control/states/IdleState.ts","../src/control/states/HoldingState.ts","../src/control/states/DraggingState.ts","../src/control/states/AnimatingState.ts","../src/control/states/DisabledState.ts","../src/control/StateMachine.ts","../src/control/AxesController.ts","../src/control/Control.ts","../src/core/AnchorPoint.ts","../src/control/SnapControl.ts","../src/control/FreeControl.ts","../src/control/StrictControl.ts","../src/camera/mode/CameraMode.ts","../src/camera/mode/LinearCameraMode.ts","../src/camera/mode/CircularCameraMode.ts","../src/camera/mode/BoundCameraMode.ts","../src/camera/Camera.ts","../src/renderer/Renderer.ts","../src/renderer/VanillaRenderer.ts","../src/renderer/ExternalRenderer.ts","../src/core/panel/Panel.ts","../src/renderer/strategy/NormalRenderingStrategy.ts","../src/core/panel/VirtualPanel.ts","../src/renderer/strategy/VirtualRenderingStrategy.ts","../src/Flicking.ts","../src/cfc/sync.ts","../src/cfc/getDefaultCameraTransform.ts","../src/cfc/withFlickingMethods.ts","../src/cfc/getRenderingPanels.ts","../src/index.umd.ts"],"sourcesContent":["/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n/* eslint-disable @typescript-eslint/restrict-template-expressions */\n\n/**\n * Error codes of {@link FlickingError}. Below are the conditions where each error code occurs.\n * @ko {@link FlickingError}의 에러 코드. 아래는 각각의 에러 코드가 발생하는 조건입니다.\n * @name ERROR_CODE\n * @constant\n * @type object\n * @property {number} WRONG_TYPE Parameter type is wrong<ko>패러미터의 타입이 잘못되었을 경우</ko>\n * @property {number} ELEMENT_NOT_FOUND Element is not found inside page with the given CSS selector<ko>주어진 CSS selector로 페이지 내에서 해당 엘리먼트를 찾지 못했을 경우</ko>\n * @property {number} VAL_MUST_NOT_NULL Expected non-null value, but given `null` or `undefined`<ko>값을 기대했으나, `null`이나 `undefined`를 받은 경우</ko>\n * @property {number} NOT_ATTACHED_TO_FLICKING When Flicking's component is not initialized (i.e. {@link Flicking#init} is not called)<ko>Flicking 내부 컴포넌트가 초기화되지 않은 경우 ({@link Flicking#init}이 호출되지 않은 경우)</ko>\n * @property {number} WRONG_OPTION One of the options is wrong<ko>옵션들 중 잘못된 값이 있을 때</ko>\n * @property {number} INDEX_OUT_OF_RANGE When the given index is out of possible range<ko>인덱스가 주어진 범위를 벗어난 경우</ko>\n * @property {number} POSITION_NOT_REACHABLE When {@link Control#moveToPosition}'s position parameter is out of possible range.<ko>{@link Control#moveToPosition}의 `position` 패러미터가 도달 가능한 범위를 벗어난 경우</ko>\n * @property {number} TRANSFORM_NOT_SUPPORTED CSS `transform` property is not available(<=IE8) <ko>CSS `transform` 속성을 사용할 수 없는 경우(<=IE8)</ko>\n * @property {number} STOP_CALLED_BY_USER When the event's `stop()` is called by user.<ko>사용자에 의해 이벤트의 `stop()`이 호출된 경우</ko>\n * @property {number} ANIMATION_INTERRUPTED When the animation is interrupted by user.<ko>사용자에 의해 애니메이션이 중단된 경우</ko>\n * @property {number} ANIMATION_ALREADY_PLAYING When the animation is already playing.<ko>현재 애니메이션이 이미 진행중인 경우</ko>\n * @property {number} NOT_ALLOWED_IN_FRAMEWORK When the non-allowed method is called from frameworks (React, Angular, Vue...)\n * <ko>프레임워크(React, Angular, Vue ...)에서 사용 불가능한 메소드를 호출했을 경우</ko>\n * @property {number} NOT_INITIALIZED When the {@link Flicking#init} is not called before but is needed<ko>{@link Flicking#init}의 호출이 필요하나, 아직 호출되지 않았을 경우</ko>\n * @property {number} NO_ACTIVE When there're no active panel that flicking has selected. This may be due to the absence of any panels<ko>현재 Flicking이 선택한 패널이 없을 경우. 일반적으로 패널이 하나도 없는 경우에 발생할 수 있습니다</ko>\n * @property {number} NOT_ALLOWED_IN_VIRTUAL When the non-allowed method is called while the virtual option is enabled<ko>virtual 옵션이 활성화된 상태에서 사용 불가능한 메소드가 호출되었을 경우</ko>\n */\nexport const CODE = {\n  WRONG_TYPE: 0,\n  ELEMENT_NOT_FOUND: 1,\n  VAL_MUST_NOT_NULL: 2,\n  NOT_ATTACHED_TO_FLICKING: 3,\n  WRONG_OPTION: 4,\n  INDEX_OUT_OF_RANGE: 5,\n  POSITION_NOT_REACHABLE: 6,\n  TRANSFORM_NOT_SUPPORTED: 7,\n  STOP_CALLED_BY_USER: 8,\n  ANIMATION_INTERRUPTED: 9,\n  ANIMATION_ALREADY_PLAYING: 10,\n  NOT_ALLOWED_IN_FRAMEWORK: 11,\n  NOT_INITIALIZED: 12,\n  NO_ACTIVE: 13,\n  NOT_ALLOWED_IN_VIRTUAL: 14\n} as const;\n\nexport const MESSAGE = {\n  WRONG_TYPE: (wrongVal: any, correctTypes: string[]) => `${wrongVal}(${typeof wrongVal}) is not a ${correctTypes.map(type => `\"${type}\"`).join(\" or \")}.`,\n  ELEMENT_NOT_FOUND: (selector: string) => `Element with selector \"${selector}\" not found.`,\n  VAL_MUST_NOT_NULL: (val: any, name: string) => `${name} should be provided. Given: ${val}`,\n  NOT_ATTACHED_TO_FLICKING: \"This module is not attached to the Flicking instance. \\\"init()\\\" should be called first.\",\n  WRONG_OPTION: (optionName: string, val: any) => `Option \"${optionName}\" is not in correct format, given: ${val}`,\n  INDEX_OUT_OF_RANGE: (val: number, min: number, max: number) => `Index \"${val}\" is out of range: should be between ${min} and ${max}.`,\n  POSITION_NOT_REACHABLE: (position: number) => `Position \"${position}\" is not reachable.`,\n  TRANSFORM_NOT_SUPPORTED: \"Browser does not support CSS transform.\",\n  STOP_CALLED_BY_USER: \"Event stop() is called by user.\",\n  ANIMATION_INTERRUPTED: \"Animation is interrupted by user input.\",\n  ANIMATION_ALREADY_PLAYING: \"Animation is already playing.\",\n  NOT_ALLOWED_IN_FRAMEWORK: \"This behavior is not allowed in the frameworks like React, Vue, or Angular.\",\n  NOT_INITIALIZED: \"Flicking is not initialized yet, call init() first.\",\n  NO_ACTIVE: \"There's no active panel that Flicking has selected. This may be due to the absence of any panels.\",\n  NOT_ALLOWED_IN_VIRTUAL: \"This behavior is not allowed when the virtual option is enabled\"\n} as const;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { OnAnimationEnd, OnChange, OnFinish, OnHold, OnRelease } from \"@egjs/axes\";\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport Flicking from \"../../Flicking\";\nimport Panel from \"../../core/panel/Panel\";\nimport { EVENTS } from \"../../const/external\";\nimport * as AXES from \"../../const/axes\";\nimport { circulatePosition, getDirection } from \"../../utils\";\n\nexport enum STATE_TYPE {\n  IDLE,\n  HOLDING,\n  DRAGGING,\n  ANIMATING,\n  DISABLED\n}\n\n/**\n * A component that shows the current status of the user input or the animation\n * @ko 현재 사용자 입력 또는 애니메이션 상태를 나타내는 컴포넌트\n * @internal\n */\nabstract class State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public abstract readonly holding: boolean;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public abstract readonly animating: boolean;\n\n  protected _delta: number = 0;\n  protected _targetPanel: Panel | null = null;\n\n  /**\n   * A sum of delta values of change events from the last hold event of Axes\n   * @ko 이전 hold이벤트부터 change에 의해 발생한 이동 delta값의 합산\n   * @type {number}\n   * @readonly\n   */\n  public get delta() { return this._delta; }\n\n  /**\n   * A panel to set as {@link Control#activePanel} after the animation is finished\n   * @ko 애니메이션 종료시 {@link Control#activePanel}로 설정할 패널\n   * @type {number}\n   * @readonly\n   */\n  public get targetPanel() { return this._targetPanel; }\n\n  public set targetPanel(val: Panel | null) { this._targetPanel = val; }\n\n  /**\n   * An callback which is called when state has changed to this state\n   * @ko 현재 상태로 돌입했을때 호출되는 콜백 함수\n   * @param {State} prevState An previous state<ko>이전 상태값</ko>\n   * @return {void}\n   */\n  public onEnter(prevState: State): void {\n    this._delta = prevState._delta;\n    this._targetPanel = prevState._targetPanel;\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} event of Axes\n   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onHold(ctx: {\n    flicking: Flicking;\n    axesEvent: OnHold;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} event of Axes\n   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onChange(ctx: {\n    flicking: Flicking;\n    axesEvent: OnChange;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of Axes\n   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onRelease(ctx: {\n    flicking: Flicking;\n    axesEvent: OnRelease;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} event of Axes\n   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onAnimationEnd(ctx: {\n    flicking: Flicking;\n    axesEvent: OnAnimationEnd;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  /**\n   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} event\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} 이벤트 핸들러\n   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>\n   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>\n   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} event of Axes<ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} 이벤트</ko>\n   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>\n   * @return {void}\n   */\n  public onFinish(ctx: {\n    flicking: Flicking;\n    axesEvent: OnFinish;\n    transitTo: (nextState: STATE_TYPE) => State;\n  }): void {\n    // DO NOTHING\n  }\n\n  protected _moveToChangedPosition(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n    const delta = axesEvent.delta[AXES.POSITION_KEY];\n\n    if (!delta) {\n      return;\n    }\n\n    this._delta += delta;\n\n    const camera = flicking.camera;\n    const prevPosition = camera.position;\n    const position = axesEvent.pos[AXES.POSITION_KEY];\n    const newPosition = flicking.circularEnabled\n      ? circulatePosition(position, camera.range.min, camera.range.max)\n      : position;\n\n    camera.lookAt(newPosition);\n\n    const moveEvent = new ComponentEvent(EVENTS.MOVE, {\n      isTrusted: axesEvent.isTrusted,\n      holding: this.holding,\n      direction: getDirection(0, axesEvent.delta[AXES.POSITION_KEY]),\n      axesEvent\n    });\n\n    flicking.trigger(moveEvent);\n\n    if (moveEvent.isCanceled()) {\n      // Return to previous position\n      camera.lookAt(prevPosition);\n      transitTo(STATE_TYPE.DISABLED);\n    }\n  }\n}\n\nexport default State;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nexport { CODE as ERROR_CODE } from \"./error\";\n\n/**\n * Event type object with event name strings of {@link Flicking}\n * @ko {@link Flicking}의 이벤트 이름 문자열들을 담은 객체\n * @type {object}\n * @property {\"holdStart\"} HOLD_START holdStart event<ko>holdStart 이벤트</ko>\n * @property {\"holdEnd\"} HOLD_END holdEnd event<ko>holdEnd 이벤트</ko>\n * @property {\"moveStart\"} MOVE_START moveStart event<ko>moveStart 이벤트</ko>\n * @property {\"move\"} MOVE move event<ko>move 이벤트</ko>\n * @property {\"moveEnd\"} MOVE_END moveEnd event<ko>moveEnd 이벤트</ko>\n * @property {\"willChange\"} WILL_CHANGE willChange event<ko>willChange 이벤트</ko>\n * @property {\"changed\"} CHANGED changed event<ko>changed 이벤트</ko>\n * @property {\"willRestore\"} WILL_RESTORE willRestore event<ko>willRestore 이벤트</ko>\n * @property {\"restored\"} RESTORED restored event<ko>restored 이벤트</ko>\n * @property {\"select\"} SELECT select event<ko>select 이벤트</ko>\n * @property {\"needPanel\"} NEED_PANEL needPanel event<ko>needPanel 이벤트</ko>\n * @property {\"panelChange\"} PANEL_CHANGE panelChange event<ko>panelChange 이벤트</ko>\n * @example\n * ```ts\n * import { EVENTS } from \"@egjs/flicking\";\n * EVENTS.MOVE_START; // \"moveStart\"\n * ```\n */\nexport const EVENTS = {\n  READY: \"ready\",\n  BEFORE_RESIZE: \"beforeResize\",\n  AFTER_RESIZE: \"afterResize\",\n  HOLD_START: \"holdStart\",\n  HOLD_END: \"holdEnd\",\n  MOVE_START: \"moveStart\",\n  MOVE: \"move\",\n  MOVE_END: \"moveEnd\",\n  WILL_CHANGE: \"willChange\",\n  CHANGED: \"changed\",\n  WILL_RESTORE: \"willRestore\",\n  RESTORED: \"restored\",\n  SELECT: \"select\",\n  NEED_PANEL: \"needPanel\",\n  VISIBLE_CHANGE: \"visibleChange\",\n  REACH_EDGE: \"reachEdge\",\n  PANEL_CHANGE: \"panelChange\"\n} as const;\n\n/**\n * An object with all possible predefined literal string for the {@link Flicking#align align} option\n * @ko {@link Flicking#align align} 옵션에 사용되는 미리 정의된 리터럴 상수들을 담고 있는 객체\n * @type {object}\n * @property {\"prev\"} PREV left/top align<ko>좌/상 정렬</ko>\n * @property {\"center\"} CENTER center align<ko>중앙 정렬</ko>\n * @property {\"next\"} NEXT right/bottom align<ko>우/하 정렬</ko>\n */\nexport const ALIGN = {\n  PREV: \"prev\",\n  CENTER: \"center\",\n  NEXT: \"next\"\n} as const;\n\n/**\n * An object of directions\n * @ko 방향을 나타내는 값들을 담고 있는 객체\n * @type {object}\n * @property {\"PREV\"} PREV \"left\" when {@link Flicking#horizontal horizontal} is true, and \"top\" when {@link Flicking#horizontal horizontal} is false\n * <ko>{@link Flicking#horizontal horizontal}가 `true`일 경우 왼쪽, {@link Flicking#horizontal horizontal}가 `false`일 경우 위쪽을 의미합니다</ko>\n * @property {\"NEXT\"} NEXT \"right\" when {@link Flicking#horizontal horizontal} is true, and \"bottom\" when {@link Flicking#horizontal horizontal} is false\n * <ko>{@link Flicking#horizontal horizontal}가 `true`일 경우 오른쪽, {@link Flicking#horizontal horizontal}가 `false`일 경우 아래쪽을 의미합니다</ko>\n * @property {null} NONE This value usually means it's the same position<ko>주로 제자리인 경우를 의미합니다</ko>\n */\nexport const DIRECTION = {\n  PREV: \"PREV\",\n  NEXT: \"NEXT\",\n  NONE: null\n} as const;\n\n/**\n * An object with all possible {@link Flicking#moveType moveType}s\n * @ko Flicking이 제공하는 {@link Flicking#moveType moveType}들을 담고 있는 객체\n * @type {object}\n * @property {\"snap\"} SNAP Flicking's {@link Flicking#moveType moveType} that enables {@link SnapControl} as a Flicking's {@link Flicking#control control}\n * <ko>Flicking의 {@link Flicking#control control}을 {@link SnapControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>\n * @property {\"freeScroll\"} FREE_SCROLL Flicking's {@link Flicking#moveType moveType} that enables {@link FreeControl} as a Flicking's {@link Flicking#control control}\n * <ko>Flicking의 {@link Flicking#control control}을 {@link FreeControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>\n * @property {\"strict\"} STRICT Flicking's {@link Flicking#moveType moveType} that enables {@link StrictControl} as a Flicking's {@link Flicking#control control}\n * <ko>Flicking의 {@link Flicking#control control}을 {@link StrictControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>\n */\nexport const MOVE_TYPE = {\n  SNAP: \"snap\",\n  FREE_SCROLL: \"freeScroll\",\n  STRICT: \"strict\"\n} as const;\n\nexport const CLASS = {\n  VERTICAL: \"vertical\",\n  HIDDEN: \"flicking-hidden\",\n  DEFAULT_VIRTUAL: \"flicking-panel\"\n};\n\n/**\n * An object with all possible {@link Flicking#circularFallback circularFallback}s\n * @ko Flicking의 {@link Flicking#circularFallback circularFallback}에 설정 가능한 값들을 담고 있는 객체\n * @type {object}\n * @property {string} LINEAR \"linear\"\n * @property {string} BOUND \"bound\"\n */\nexport const CIRCULAR_FALLBACK = {\n  LINEAR: \"linear\",\n  BOUND: \"bound\"\n} as const;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking, { FlickingOptions } from \"./Flicking\";\nimport FlickingError from \"./core/FlickingError\";\nimport * as ERROR from \"./const/error\";\nimport { ALIGN, DIRECTION } from \"./const/external\";\nimport { LiteralUnion, Merged, ValueOf } from \"./type/internal\";\nimport { ElementLike } from \"./type/external\";\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const merge = <From extends object, To extends object>(target: From, ...sources: To[]): Merged<From, To> => {\n  sources.forEach(source => {\n    Object.keys(source).forEach(key => {\n      target[key] = source[key] as unknown;\n    });\n  });\n\n  return target as Merged<From, To>;\n};\n\nexport const getElement = (el: HTMLElement | string | null, parent?: HTMLElement): HTMLElement => {\n  let targetEl: HTMLElement | null = null;\n\n  if (isString(el)) {\n    const parentEl = parent ? parent : document;\n    const queryResult = parentEl.querySelector(el);\n    if (!queryResult) {\n      throw new FlickingError(ERROR.MESSAGE.ELEMENT_NOT_FOUND(el), ERROR.CODE.ELEMENT_NOT_FOUND);\n    }\n    targetEl = queryResult as HTMLElement;\n  } else if (el && el.nodeType === Node.ELEMENT_NODE) {\n    targetEl = el;\n  }\n\n  if (!targetEl) {\n    throw new FlickingError(ERROR.MESSAGE.WRONG_TYPE(el, [\"HTMLElement\", \"string\"]), ERROR.CODE.WRONG_TYPE);\n  }\n\n  return targetEl;\n};\n\nexport const checkExistence = (value: any, nameOnErrMsg: string) => {\n  if (value == null) {\n    throw new FlickingError(ERROR.MESSAGE.VAL_MUST_NOT_NULL(value, nameOnErrMsg), ERROR.CODE.VAL_MUST_NOT_NULL);\n  }\n};\n\nexport const clamp = (x: number, min: number, max: number) => Math.max(Math.min(x, max), min);\n\nexport const getFlickingAttached = (val: Flicking | null): Flicking => {\n  if (!val) {\n    throw new FlickingError(ERROR.MESSAGE.NOT_ATTACHED_TO_FLICKING, ERROR.CODE.NOT_ATTACHED_TO_FLICKING);\n  }\n\n  return val;\n};\n\nexport const toArray = <T>(iterable: ArrayLike<T>): T[] => [].slice.call(iterable) as T[];\n\nexport const parseAlign = (align: LiteralUnion<ValueOf<typeof ALIGN>> | number, size: number): number => {\n  let alignPoint: number | null;\n  if (isString(align)) {\n    switch (align) {\n      case ALIGN.PREV:\n        alignPoint = 0;\n        break;\n      case ALIGN.CENTER:\n        alignPoint = 0.5 * size;\n        break;\n      case ALIGN.NEXT:\n        alignPoint = size;\n        break;\n      default:\n        alignPoint = parseArithmeticSize(align, size);\n        if (alignPoint == null) {\n          throw new FlickingError(ERROR.MESSAGE.WRONG_OPTION(\"align\", align), ERROR.CODE.WRONG_OPTION);\n        }\n    }\n  } else {\n    alignPoint = align as number;\n  }\n\n  return alignPoint;\n};\n\nexport const parseBounce = (bounce: FlickingOptions[\"bounce\"], size: number): number[] => {\n  let parsedBounce: Array<number | null>;\n\n  if (Array.isArray(bounce)) {\n    parsedBounce = (bounce as string[]).map(val => parseArithmeticSize(val, size));\n  } else {\n    const parsedVal = parseArithmeticSize(bounce, size);\n\n    parsedBounce = [parsedVal, parsedVal];\n  }\n\n  return parsedBounce.map(val => {\n    if (val == null) {\n      throw new FlickingError(ERROR.MESSAGE.WRONG_OPTION(\"bounce\", bounce), ERROR.CODE.WRONG_OPTION);\n    }\n    return val;\n  });\n};\n\nexport const parseArithmeticSize = (cssValue: number | string, base: number): number | null => {\n  const parsed = parseArithmeticExpression(cssValue);\n\n  if (parsed == null) return null;\n\n  return parsed.percentage * base + parsed.absolute;\n};\n\nexport const parseArithmeticExpression = (cssValue: number | string): { percentage: number; absolute: number } | null => {\n  const cssRegex = /(?:(\\+|\\-)\\s*)?(\\d+(?:\\.\\d+)?(%|px)?)/g;\n\n  if (typeof cssValue === \"number\") {\n    return { percentage: 0, absolute: cssValue };\n  }\n\n  const parsed = {\n    percentage: 0,\n    absolute: 0\n  };\n  let idx = 0;\n  let matchResult = cssRegex.exec(cssValue);\n  while (matchResult != null) {\n    let sign = matchResult[1];\n    const value = matchResult[2];\n    const unit = matchResult[3];\n    const parsedValue = parseFloat(value);\n\n    if (idx <= 0) {\n      sign = sign || \"+\";\n    }\n\n    // Return default value for values not in good form\n    if (!sign) {\n      return null;\n    }\n\n    const signMultiplier = sign === \"+\" ? 1 : -1;\n\n    if (unit === \"%\") {\n      parsed.percentage += signMultiplier * (parsedValue / 100);\n    } else {\n      parsed.absolute += signMultiplier * parsedValue;\n    }\n\n    // Match next occurrence\n    ++idx;\n    matchResult = cssRegex.exec(cssValue);\n  }\n\n  // None-matched\n  if (idx === 0) {\n    return null;\n  }\n\n  return parsed;\n};\n\nexport const parseCSSSizeValue = (val: string | number): string => isString(val) ? val : `${val}px`;\n\nexport const parsePanelAlign = (align: FlickingOptions[\"align\"]) => typeof align === \"object\"\n  ? (align as { panel: string | number }).panel\n  : align;\n\nexport const getDirection = (start: number, end: number): ValueOf<typeof DIRECTION> => {\n  if (start === end) return DIRECTION.NONE;\n  return start < end ? DIRECTION.NEXT : DIRECTION.PREV;\n};\n\nexport const parseElement = (element: ElementLike | ElementLike[]): HTMLElement[] => {\n  if (!Array.isArray(element)) {\n    element = [element];\n  }\n\n  const elements: HTMLElement[] = [];\n  element.forEach(el => {\n    if (isString(el)) {\n      const tempDiv = document.createElement(\"div\");\n      tempDiv.innerHTML = el;\n\n      elements.push(...toArray(tempDiv.children) as HTMLElement[]);\n      while (tempDiv.firstChild) {\n        tempDiv.removeChild(tempDiv.firstChild);\n      }\n    } else if (el && el.nodeType === Node.ELEMENT_NODE) {\n      elements.push(el);\n    } else {\n      throw new FlickingError(ERROR.MESSAGE.WRONG_TYPE(el, [\"HTMLElement\", \"string\"]), ERROR.CODE.WRONG_TYPE);\n    }\n  });\n\n  return elements;\n};\n\nexport const getMinusCompensatedIndex = (idx: number, max: number) => idx < 0 ? clamp(idx + max, 0, max) : clamp(idx, 0, max);\n\nexport const includes = <T>(array: T[], target: any): target is T => {\n  for (const val of array) {\n    if (val === target) return true;\n  }\n  return false;\n};\n\nexport const isString = (val: any): val is string => typeof val === \"string\";\n\nexport const circulatePosition = (pos: number, min: number, max: number) => {\n  const size = max - min;\n\n  if (pos < min) {\n    const offset = (min - pos) % size;\n    pos = max - offset;\n  } else if (pos > max) {\n    const offset = (pos - max) % size;\n    pos = min + offset;\n  }\n\n  return pos;\n};\n\nexport const find = <T>(array: T[], checker: (val: T) => boolean): T | null => {\n  for (const val of array) {\n    if (checker(val)) {\n      return val;\n    }\n  }\n\n  return null;\n};\n\nexport const findRight = <T>(array: T[], checker: (val: T) => boolean): T | null => {\n  for (let idx = array.length - 1; idx >= 0; idx--) {\n    const val = array[idx];\n    if (checker(val)) {\n      return val;\n    }\n  }\n\n  return null;\n};\n\nexport const findIndex = <T>(array: T[], checker: (val: T) => boolean): number => {\n  for (let idx = 0; idx < array.length; idx++) {\n    if (checker(array[idx])) {\n      return idx;\n    }\n  }\n\n  return -1;\n};\n\nexport const getProgress = (pos: number, prev: number, next: number) => (pos - prev) / (next - prev);\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nexport const getStyle = (el: HTMLElement): CSSStyleDeclaration => window.getComputedStyle(el) || (el as any).currentStyle as CSSStyleDeclaration;\n\nexport const setSize = (el: HTMLElement, { width, height }: Partial<{\n  width: number | string;\n  height: number | string;\n}>) => {\n  if (width != null) {\n    if (isString(width)) {\n      el.style.width = width;\n    } else {\n      el.style.width = `${width}px`;\n    }\n  }\n  if (height != null) {\n    if (isString(height)) {\n      el.style.height = height;\n    } else {\n      el.style.height = `${height}px`;\n    }\n  }\n};\n\nexport const isBetween = (val: number, min: number, max: number) => val >= min && val <= max;\n\nexport const circulateIndex = (index: number, max: number): number => {\n  if (index >= max) {\n    return index % max;\n  } else if (index < 0) {\n    return getMinusCompensatedIndex((index + 1) % max - 1, max);\n  } else {\n    return index;\n  }\n};\n\nexport const range = (end: number): number[] => {\n  const arr = new Array(end);\n\n  for (let i = 0; i < end; i++) {\n    arr[i] = i;\n  }\n\n  return arr;\n};\n\nexport const setPrototypeOf = Object.setPrototypeOf || ((obj, proto) => {\n  obj.__proto__ = proto;\n  return obj;\n});\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport { setPrototypeOf } from \"../utils\";\n\n/**\n * Special type of known error that {@link Flicking} throws.\n * @ko Flicking 내부에서 알려진 오류 발생시 throw되는 에러\n * @property {number} code Error code<ko>에러 코드</ko>\n * @property {string} message Error message<ko>에러 메시지</ko>\n * @see {@link Constants.ERROR_CODE ERROR_CODE}\n * @example\n * ```ts\n * import Flicking, { FlickingError, ERROR_CODES } from \"@egjs/flicking\";\n * try {\n *   const flicking = new Flicking(\".flicking-viewport\")\n * } catch (e) {\n *   if (e instanceof FlickingError && e.code === ERROR_CODES.ELEMENT_NOT_FOUND) {\n *     console.error(\"Element not found\")\n *   }\n * }\n * ```\n */\nclass FlickingError extends Error {\n  public code: number;\n\n  /**\n   * @param message Error message<ko>에러 메시지</ko>\n   * @param code Error code<ko>에러 코드</ko>\n   */\n  public constructor(message: string, code: number) {\n    super(message);\n\n    setPrototypeOf(this, FlickingError.prototype);\n    this.name = \"FlickingError\";\n    this.code = code;\n  }\n}\n\nexport default FlickingError;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { getStyle, isString } from \"../utils\";\n\n/**\n * A component that manages viewport size\n * @ko 뷰포트 크기 정보를 담당하는 컴포넌트\n */\nclass Viewport {\n  private _el: HTMLElement;\n  private _width: number;\n  private _height: number;\n  private _isBorderBoxSizing: boolean;\n  private _padding: {\n    left: number;\n    right: number;\n    top: number;\n    bottom: number;\n  };\n\n  /**\n   * A viewport(root) element\n   * @ko 뷰포트(root) 엘리먼트\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._el; }\n\n  /**\n   * Viewport width, without paddings\n   * @ko 뷰포트 너비\n   * @type {number}\n   * @readonly\n   */\n  public get width() { return this._width - this._padding.left - this._padding.right; }\n  /**\n   * Viewport height, without paddings\n   * @ko 뷰포트 높이\n   * @type {number}\n   * @readonly\n   */\n  public get height() { return this._height - this._padding.top - this._padding.bottom; }\n  /**\n   * Viewport paddings\n   * @ko 뷰포트 CSS padding 값\n   * @type {object}\n   * @property {number} left CSS `padding-left`\n   * @property {number} right CSS `padding-right`\n   * @property {number} top CSS `padding-top`\n   * @property {number} bottom CSS `padding-bottom`\n   * @readonly\n   */\n  public get padding() { return this._padding; }\n\n  /**\n   * @param el A viewport element<ko>뷰포트 엘리먼트</ko>\n   */\n  public constructor(el: HTMLElement) {\n    this._el = el;\n    this._width = 0;\n    this._height = 0;\n    this._padding = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    this._isBorderBoxSizing = false;\n  }\n\n  /**\n   * Change viewport's size.\n   * This will change the actual size of `.flicking-viewport` element by changing its CSS width/height property\n   * @ko 뷰포트 크기를 변경합니다.\n   * `.flicking-viewport` 엘리먼트에 해당 크기의 CSS width/height를 적용합니다\n   * @param {object} [size] New viewport size<ko>새 뷰포트 크기</ko>\n   * @param {number|string} [size.width] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>\n   * @param {number|string} [size.height] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>\n   */\n  public setSize({\n    width,\n    height\n  }: Partial<{\n    width: number | string;\n    height: number | string;\n  }>) {\n    const el = this._el;\n    const padding = this._padding;\n    const isBorderBoxSizing = this._isBorderBoxSizing;\n\n    if (width != null) {\n      if (isString(width)) {\n        el.style.width = width;\n      } else {\n        const newWidth = isBorderBoxSizing\n          ? width + padding.left + padding.right\n          : width;\n        el.style.width = `${newWidth}px`;\n      }\n    }\n    if (height != null) {\n      if (isString(height)) {\n        el.style.height = height;\n      } else {\n        const newHeight = isBorderBoxSizing\n          ? height + padding.top + padding.bottom\n          : height;\n        el.style.height = `${newHeight}px`;\n      }\n    }\n    this.resize();\n  }\n\n  /**\n   * Update width/height to the current viewport element's size\n   * @ko 현재 뷰포트 엘리먼트의 크기로 너비/높이를 업데이트합니다\n   */\n  public resize() {\n    const el = this._el;\n    const elStyle = getStyle(el);\n\n    this._width = el.clientWidth;\n    this._height = el.clientHeight;\n    this._padding = {\n      left: elStyle.paddingLeft ? parseFloat(elStyle.paddingLeft) : 0,\n      right: elStyle.paddingRight ? parseFloat(elStyle.paddingRight) : 0,\n      top: elStyle.paddingTop ? parseFloat(elStyle.paddingTop) : 0,\n      bottom: elStyle.paddingBottom ? parseFloat(elStyle.paddingBottom) : 0\n    };\n    this._isBorderBoxSizing = elStyle.boxSizing === \"border-box\";\n  }\n}\n\nexport default Viewport;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../Flicking\";\n\nclass AutoResizer {\n  private _flicking: Flicking;\n  private _enabled: boolean;\n  private _resizeObserver: ResizeObserver | null;\n\n  public get enabled() { return this._enabled; }\n\n  public constructor(flicking: Flicking) {\n    this._flicking = flicking;\n    this._enabled = false;\n    this._resizeObserver = null;\n  }\n\n  public enable(): this {\n    const flicking = this._flicking;\n    const viewport = flicking.viewport;\n\n    if (this._enabled) {\n      this.disable();\n    }\n\n    if (flicking.useResizeObserver && !!window.ResizeObserver) {\n      const viewportSizeNot0 = viewport.width !== 0 || viewport.height !== 0;\n\n      const resizeObserver = viewportSizeNot0\n        ? new ResizeObserver(this._skipFirstResize)\n        : new ResizeObserver(this._onResize);\n\n      resizeObserver.observe(flicking.viewport.element);\n\n      this._resizeObserver = resizeObserver;\n    } else {\n      window.addEventListener(\"resize\", this._onResize);\n    }\n\n    this._enabled = true;\n\n    return this;\n  }\n\n  public disable(): this {\n    if (!this._enabled) return this;\n\n    const resizeObserver = this._resizeObserver;\n    if (resizeObserver) {\n      resizeObserver.disconnect();\n      this._resizeObserver = null;\n    } else {\n      window.removeEventListener(\"resize\", this._onResize);\n    }\n\n    this._enabled = false;\n\n    return this;\n  }\n\n  private _onResize = () => {\n    void this._flicking.resize();\n  };\n\n  // eslint-disable-next-line @typescript-eslint/member-ordering\n  private _skipFirstResize = (() => {\n    let isFirstResize = true;\n\n    return (() => {\n      if (isFirstResize) {\n        isFirstResize = false;\n        return;\n      }\n      this._onResize();\n    });\n  })();\n}\n\nexport default AutoResizer;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../../../Flicking\";\n\nimport ElementProvider from \"./ElementProvider\";\n\n/**\n * @internal\n */\nclass VanillaElementProvider implements ElementProvider {\n  private _element: HTMLElement;\n  private _rendered: boolean;\n\n  public get element() { return this._element; }\n  public get rendered() { return this._rendered; }\n\n  public constructor(element: HTMLElement) {\n    this._element = element;\n    this._rendered = true;\n  }\n\n  public show(flicking: Flicking): void {\n    const el = this.element;\n    const cameraEl = flicking.camera.element;\n\n    if (el.parentElement !== cameraEl) {\n      cameraEl.appendChild(el);\n      this._rendered = true;\n    }\n  }\n\n  public hide(flicking: Flicking): void {\n    const el = this.element;\n    const cameraEl = flicking.camera.element;\n\n    if (el.parentElement === cameraEl) {\n      cameraEl.removeChild(el);\n      this._rendered = false;\n    }\n  }\n}\n\nexport default VanillaElementProvider;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\nimport Flicking from \"../../../Flicking\";\nimport VirtualPanel from \"../VirtualPanel\";\n\nimport ElementProvider from \"./ElementProvider\";\n\n/**\n * @internal\n */\nclass VirtualElementProvider implements ElementProvider {\n  private _flicking: Flicking;\n  private _panel: VirtualPanel;\n\n  public get element() { return this._virtualElement.nativeElement; }\n  public get rendered() { return this._virtualElement.visible; }\n\n  private get _virtualElement() {\n    const flicking = this._flicking;\n    const elIndex = this._panel.elementIndex;\n    const virtualElements = flicking.virtual.elements;\n\n    return virtualElements[elIndex];\n  }\n\n  public constructor(flicking: Flicking) {\n    this._flicking = flicking;\n  }\n\n  public init(panel: VirtualPanel) {\n    this._panel = panel;\n  }\n\n  public show(): void {\n    // DO_NOTHING\n    // Actual element visibility is controlled by VirtualManager\n  }\n\n  public hide(): void {\n    // DO_NOTHING\n    // Actual element visibility is controlled by VirtualManager\n  }\n}\n\nexport default VirtualElementProvider;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../Flicking\";\nimport { range } from \"../utils\";\nimport { CLASS } from \"../const/external\";\n\nimport VirtualPanel from \"./panel/VirtualPanel\";\n\nexport interface VirtualOptions {\n  renderPanel: (panel: VirtualPanel, index: number) => string;\n  initialPanelCount: number;\n  cache?: boolean;\n  panelClass?: string;\n}\n\n/**\n * A manager class to add / remove virtual panels\n */\nclass VirtualManager {\n  private _flicking: Flicking;\n\n  private _renderPanel: (panel: VirtualPanel, index: number) => string;\n  private _initialPanelCount: number;\n  private _cache: boolean;\n  private _panelClass: string;\n\n  private _elements: Array<{ nativeElement: HTMLElement; visible: boolean }>;\n\n  public get elements() { return this._elements; }\n\n  // Options\n  /**\n   * A rendering function for the panel element's innerHTML\n   * @ko 패널 엘리먼트의 innerHTML을 렌더링하는 함수\n   * @type {function}\n   * @param {VirtualPanel} panel Instance of the panel<ko>패널 인스턴스</ko>\n   * @param {number} index Index of the panel<ko>패널 인덱스</ko>\n   * @default \"() => {}\"\n   */\n  public get renderPanel() { return this._renderPanel; }\n  /**\n   * Initial panel count to render\n   * @ko 최초로 렌더링할 패널의 개수\n   * @readonly\n   * @type {number}\n   * @default -1\n   */\n  public get initialPanelCount() { return this._initialPanelCount; }\n  /**\n   * Whether to cache rendered panel's innerHTML\n   * @ko 렌더링된 패널의 innerHTML 정보를 캐시할지 여부\n   * @type {boolean}\n   * @default false\n   */\n  public get cache() { return this._cache; }\n  /**\n   * The class name that will be applied to rendered panel elements\n   * @ko 렌더링되는 패널 엘리먼트에 적용될 클래스 이름\n   * @type {string}\n   * @default \"flicking-panel\"\n   */\n  public get panelClass() { return this._panelClass; }\n\n  public set renderPanel(val: VirtualOptions[\"renderPanel\"]) {\n    this._renderPanel = val;\n    this._flicking.renderer.panels.forEach((panel: VirtualPanel) => panel.uncacheRenderResult());\n  }\n\n  public set cache(val: NonNullable<VirtualOptions[\"cache\"]>) { this._cache = val; }\n  public set panelClass(val: NonNullable<VirtualOptions[\"panelClass\"]>) { this._panelClass = val; }\n\n  public constructor(flicking: Flicking, options: VirtualOptions | null) {\n    this._flicking = flicking;\n\n    this._renderPanel = options?.renderPanel ?? (() => \"\");\n    this._initialPanelCount = options?.initialPanelCount ?? -1;\n    this._cache = options?.cache ?? false;\n    this._panelClass = options?.panelClass ?? CLASS.DEFAULT_VIRTUAL;\n\n    this._elements = [];\n  }\n\n  public init() {\n    const flicking = this._flicking;\n\n    if (!flicking.virtualEnabled) return;\n\n    if (!flicking.externalRenderer && !flicking.renderExternal) {\n      this._initVirtualElements();\n    }\n\n    const virtualElements = flicking.camera.children;\n    this._elements = virtualElements.map(el => ({ nativeElement: el, visible: true }));\n  }\n\n  public show(index: number) {\n    const el = this._elements[index];\n    const nativeEl = el.nativeElement;\n\n    el.visible = true;\n\n    if (nativeEl.style.display) {\n      nativeEl.style.display = \"\";\n    }\n  }\n\n  public hide(index: number) {\n    const el = this._elements[index];\n    const nativeEl = el.nativeElement;\n\n    el.visible = false;\n    nativeEl.style.display = \"none\";\n  }\n\n  /**\n   * Add new virtual panels at the end of the list\n   * @ko 새로운 가상 패널들을 리스트의 끝에 추가합니다\n   * @param {number} count The number of panels to add<ko>추가할 패널의 개수</ko>\n   * @returns {Array<VirtualPanel>} The new panels added<ko>새롭게 추가된 패널들</ko>\n   */\n  public append(count: number = 1): VirtualPanel[] {\n    const flicking = this._flicking;\n\n    return this.insert(flicking.panels.length, count);\n  }\n\n  /**\n   * Add new virtual panels at the start of the list\n   * @ko 새로운 가상 패널들을 리스트의 시작에 추가합니다\n   * @param {number} count The number of panels to add<ko>추가할 패널의 개수</ko>\n   * @returns {Array<VirtualPanel>} The new panels added<ko>새롭게 추가된 패널들</ko>\n   */\n  public prepend(count: number = 1): VirtualPanel[] {\n    return this.insert(0, count);\n  }\n\n  /**\n   * Add new virtual panels at the given index\n   * @ko 새로운 가상 패널들을 주어진 인덱스에 추가합니다\n   * @param {number} count The number of panels to add<ko>추가할 패널의 개수</ko>\n   * @returns {Array<VirtualPanel>} The new panels added<ko>새롭게 추가된 패널들</ko>\n   */\n  public insert(index: number, count: number = 1): VirtualPanel[] {\n    if (count <= 0) return [];\n\n    const flicking = this._flicking;\n\n    return flicking.renderer.batchInsert({ index, elements: range(count), hasDOMInElements: false }) as VirtualPanel[];\n  }\n\n  /**\n   * Remove panels at the given index\n   * @ko 주어진 인덱스에서 패널들을 삭제합니다\n   * @param {number} count The number of panels to remove<ko>삭제할 패널의 개수</ko>\n   * @returns {Array<VirtualPanel>} The panels removed<ko>삭제된 패널들</ko>\n   */\n  public remove(index: number, count: number): VirtualPanel[] {\n    if (count <= 0) return [];\n\n    const flicking = this._flicking;\n\n    return flicking.renderer.batchRemove({ index, deleteCount: count, hasDOMInElements: false }) as VirtualPanel[];\n  }\n\n  private _initVirtualElements() {\n    const flicking = this._flicking;\n    const cameraElement = flicking.camera.element;\n    const panelsPerView = flicking.panelsPerView;\n    const fragment = document.createDocumentFragment();\n\n    const newElements = range(panelsPerView + 1).map(idx => {\n      const panelEl = document.createElement(\"div\");\n      panelEl.className = this._panelClass;\n      panelEl.dataset.elementIndex = idx.toString();\n      return panelEl;\n    });\n\n    newElements.forEach(el => {\n      fragment.appendChild(el);\n    });\n\n    cameraElement.appendChild(fragment);\n  }\n}\n\nexport default VirtualManager;\n","/**\n * All possible @egjs/axes event keys\n * @internal\n */\nexport const EVENT = {\n  HOLD: \"hold\",\n  CHANGE: \"change\",\n  RELEASE: \"release\",\n  ANIMATION_END: \"animationEnd\",\n  FINISH: \"finish\"\n} as const;\n\n/**\n * An Axis key that Flicking uses\n * @internal\n */\nexport const POSITION_KEY = \"flick\";\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport { EVENTS } from \"../../const/external\";\nimport { getDirection } from \"../../utils\";\n\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A default state when there's no user input and no animation's playing\n * @ko 사용자의 입력이 없고, 애니메이션이 동작하고있지 않은 기본 상태\n * @internal\n */\nclass IdleState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly holding = false;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly animating = false;\n\n  public onEnter() {\n    this._delta = 0;\n    this._targetPanel = null;\n  }\n\n  public onHold(ctx: Parameters<State[\"onHold\"]>[0]): void {\n    // Shouldn't do any action until any panels on flicking area\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    if (flicking.renderer.panelCount <= 0) {\n      transitTo(STATE_TYPE.DISABLED);\n      return;\n    }\n\n    const holdStartEvent = new ComponentEvent(EVENTS.HOLD_START, {\n      axesEvent\n    });\n\n    flicking.trigger(holdStartEvent);\n\n    if (holdStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      transitTo(STATE_TYPE.HOLDING);\n    }\n  }\n\n  // By methods call\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n    const controller = flicking.control.controller;\n    const animatingContext = controller.animatingContext;\n\n    const moveStartEvent = new ComponentEvent(EVENTS.MOVE_START, {\n      isTrusted: axesEvent.isTrusted,\n      holding: this.holding,\n      direction: getDirection(animatingContext.start, animatingContext.end),\n      axesEvent\n    });\n    flicking.trigger(moveStartEvent);\n\n    if (moveStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      // Trigger AnimatingState's onChange, to trigger \"move\" event immediately\n      transitTo(STATE_TYPE.ANIMATING).onChange(ctx);\n    }\n  }\n}\n\nexport default IdleState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport Panel from \"../../core/panel/Panel\";\nimport { EVENTS } from \"../../const/external\";\nimport { getDirection } from \"../../utils\";\n\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A state that activates when user's holding the Flicking area, but not moved a single pixel yet\n * @ko 사용자의 입력이 시작되었으나, 아직 움직이지는 않은 상태\n * @internal\n */\nclass HoldingState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly holding = true;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly animating = false;\n\n  private _releaseEvent: OnRelease | null = null;\n\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    const inputEvent = axesEvent.inputEvent as { offsetX: number; offsetY: number };\n\n    const offset = flicking.horizontal\n      ? inputEvent.offsetX\n      : inputEvent.offsetY;\n\n    const moveStartEvent = new ComponentEvent(EVENTS.MOVE_START, {\n      isTrusted: axesEvent.isTrusted,\n      holding: this.holding,\n      direction: getDirection(0, -offset),\n      axesEvent\n    });\n    flicking.trigger(moveStartEvent);\n\n    if (moveStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      // Trigger DraggingState's onChange, to trigger \"move\" event immediately\n      transitTo(STATE_TYPE.DRAGGING).onChange(ctx);\n    }\n  }\n\n  public onRelease(ctx: Parameters<State[\"onRelease\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    flicking.trigger(new ComponentEvent(EVENTS.HOLD_END, { axesEvent }));\n\n    if (axesEvent.delta.flick !== 0) {\n      // Sometimes \"release\" event on axes triggered before \"change\" event\n      // Especially if user flicked panel fast in really short amount of time\n      // if delta is not zero, that means above case happened.\n\n      // Event flow should be HOLD_START -> MOVE_START -> MOVE -> HOLD_END\n      // At least one move event should be included between holdStart and holdEnd\n      axesEvent.setTo({ flick: flicking.camera.position }, 0);\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    // Can't handle select event here,\n    // As \"finish\" axes event happens\n    this._releaseEvent = axesEvent;\n  }\n\n  public onFinish(ctx: Parameters<State[\"onFinish\"]>[0]): void {\n    const { flicking, transitTo } = ctx;\n\n    // Should transite to IDLE state before select event\n    // As user expects hold is already finished\n    transitTo(STATE_TYPE.IDLE);\n\n    if (!this._releaseEvent) {\n      return;\n    }\n\n    // Handle release event here\n    // To prevent finish event called twice\n    const releaseEvent = this._releaseEvent;\n\n    // Static click\n    /* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access */\n    const srcEvent = releaseEvent.inputEvent.srcEvent;\n\n    let clickedElement: HTMLElement;\n    if (srcEvent.type === \"touchend\") {\n      const touchEvent = srcEvent as TouchEvent;\n      const touch = touchEvent.changedTouches[0];\n      clickedElement = document.elementFromPoint(touch.clientX, touch.clientY) as HTMLElement;\n    } else {\n      clickedElement = srcEvent.target;\n    }\n    /* eslint-enable */\n\n    const panels = flicking.renderer.panels;\n    let clickedPanel: Panel | null = null;\n\n    for (const panel of panels) {\n      if (panel.contains(clickedElement)) {\n        clickedPanel = panel;\n        break;\n      }\n    }\n\n    if (clickedPanel) {\n      const cameraPosition = flicking.camera.position;\n      const clickedPanelPosition = clickedPanel.position;\n\n      flicking.trigger(new ComponentEvent(EVENTS.SELECT, {\n        index: clickedPanel.index,\n        panel: clickedPanel,\n        // Direction to the clicked panel\n        direction: getDirection(cameraPosition, clickedPanelPosition)\n      }));\n    }\n  }\n}\n\nexport default HoldingState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport { EVENTS } from \"../../const/external\";\nimport * as AXES from \"../../const/axes\";\n\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A state that activates when user's dragging the Flicking area\n * @ko 사용자가 드래깅중인 상태\n * @internal\n */\nclass DraggingState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly holding = true;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly animating = true;\n\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    this._moveToChangedPosition(ctx);\n  }\n\n  public onRelease(ctx: Parameters<State[\"onRelease\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    // Update last position to cope with Axes's animating behavior\n    // Axes uses start position when animation start\n    flicking.trigger(new ComponentEvent(EVENTS.HOLD_END, {\n      axesEvent\n    }));\n\n    if (flicking.renderer.panelCount <= 0) {\n      // There're no panels\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    transitTo(STATE_TYPE.ANIMATING);\n\n    const control = flicking.control;\n    const position = axesEvent.destPos[AXES.POSITION_KEY];\n    const duration = Math.max(axesEvent.duration, flicking.duration);\n\n    void control.moveToPosition(position, duration, axesEvent);\n  }\n}\n\nexport default DraggingState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport { EVENTS } from \"../../const/external\";\nimport { getDirection } from \"../../utils\";\n\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A state that activates when Flicking's animating by user input or method call\n * @ko 사용자 입력이나 메소드 호출에 의해 Flicking의 애니메이션이 동작중인 상태\n * @internal\n */\nclass AnimatingState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly holding = false;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly animating = true;\n\n  public onHold(ctx: Parameters<State[\"onHold\"]>[0]): void {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    this._delta = 0;\n    flicking.control.updateInput();\n\n    const holdStartEvent = new ComponentEvent(EVENTS.HOLD_START, { axesEvent });\n    flicking.trigger(holdStartEvent);\n\n    if (holdStartEvent.isCanceled()) {\n      transitTo(STATE_TYPE.DISABLED);\n    } else {\n      transitTo(STATE_TYPE.DRAGGING);\n    }\n  }\n\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    this._moveToChangedPosition(ctx);\n  }\n\n  public onFinish(ctx: Parameters<State[\"onFinish\"]>[0]) {\n    const { flicking, axesEvent, transitTo } = ctx;\n\n    const control = flicking.control;\n    const controller = control.controller;\n    const animatingContext = controller.animatingContext;\n\n    transitTo(STATE_TYPE.IDLE);\n\n    flicking.trigger(new ComponentEvent(EVENTS.MOVE_END, {\n      isTrusted: axesEvent.isTrusted,\n      direction: getDirection(animatingContext.start, animatingContext.end),\n      axesEvent\n    }));\n\n    control.setActive(this._targetPanel!, control.activePanel, axesEvent.isTrusted);\n  }\n}\n\nexport default AnimatingState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport State, { STATE_TYPE } from \"./State\";\n\n/**\n * A state that activates when Flicking is stopped by event's `stop` method\n * @ko 이벤트의 `stop`호출에 의해 Flicking이 정지된 상태\n * @internal\n */\nclass DisabledState extends State {\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {false}\n   * @readonly\n   */\n  public readonly holding = false;\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {true}\n   * @readonly\n   */\n  public readonly animating = true;\n\n  public onAnimationEnd(ctx: Parameters<State[\"onAnimationEnd\"]>[0]): void {\n    const { transitTo } = ctx;\n\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onChange(ctx: Parameters<State[\"onChange\"]>[0]): void {\n    const { axesEvent, transitTo } = ctx;\n\n    // Can stop Axes's change event\n    axesEvent.stop();\n\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onRelease(ctx: Parameters<State[\"onRelease\"]>[0]): void {\n    const { axesEvent, transitTo } = ctx;\n\n    // This is needed when stopped hold start event\n    if (axesEvent.delta.flick === 0) {\n      transitTo(STATE_TYPE.IDLE);\n    }\n  }\n}\n\nexport default DisabledState;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { AxesEvents } from \"@egjs/axes\";\n\nimport Flicking from \"../Flicking\";\nimport * as AXES from \"../const/axes\";\n\nimport IdleState from \"./states/IdleState\";\nimport HoldingState from \"./states/HoldingState\";\nimport DraggingState from \"./states/DraggingState\";\nimport AnimatingState from \"./states/AnimatingState\";\nimport DisabledState from \"./states/DisabledState\";\nimport State, { STATE_TYPE } from \"./states/State\";\n\n/**\n * @internal\n */\nclass StateMachine {\n  private _state: State;\n\n  public get state(): State { return this._state; }\n\n  public constructor() {\n    this._state = new IdleState();\n  }\n\n  public fire(eventType: keyof AxesEvents, externalCtx: {\n    flicking: Flicking;\n    axesEvent: any;\n  }) {\n    const currentState = this._state;\n    const ctx = { ...externalCtx, transitTo: this.transitTo };\n\n    switch (eventType) {\n      case AXES.EVENT.HOLD:\n        currentState.onHold(ctx);\n        break;\n      case AXES.EVENT.CHANGE:\n        currentState.onChange(ctx);\n        break;\n      case AXES.EVENT.RELEASE:\n        currentState.onRelease(ctx);\n        break;\n      case AXES.EVENT.ANIMATION_END:\n        currentState.onAnimationEnd(ctx);\n        break;\n      case AXES.EVENT.FINISH:\n        currentState.onFinish(ctx);\n        break;\n    }\n  }\n\n  public transitTo = (nextStateType: STATE_TYPE): State => {\n    let nextState: State;\n\n    switch (nextStateType) {\n      case STATE_TYPE.IDLE:\n        nextState = new IdleState();\n        break;\n      case STATE_TYPE.HOLDING:\n        nextState = new HoldingState();\n        break;\n      case STATE_TYPE.DRAGGING:\n        nextState = new DraggingState();\n        break;\n      case STATE_TYPE.ANIMATING:\n        nextState = new AnimatingState();\n        break;\n      case STATE_TYPE.DISABLED:\n        nextState = new DisabledState();\n        break;\n    }\n\n    nextState.onEnter(this._state);\n\n    this._state = nextState;\n\n    return this._state;\n  };\n}\n\nexport default StateMachine;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Axes, { PanInput, AxesEvents, OnRelease } from \"@egjs/axes\";\n\nimport Flicking from \"../Flicking\";\nimport FlickingError from \"../core/FlickingError\";\nimport * as AXES from \"../const/axes\";\nimport * as ERROR from \"../const/error\";\nimport { circulatePosition, getFlickingAttached, parseBounce } from \"../utils\";\nimport { ControlParams } from \"../type/external\";\n\nimport StateMachine from \"./StateMachine\";\n\n/**\n * A controller that handles the {@link https://naver.github.io/egjs-axes/ @egjs/axes} events\n * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 이벤트를 처리하는 컨트롤러 컴포넌트\n * @internal\n */\nclass AxesController {\n  private _flicking: Flicking | null;\n  private _axes: Axes | null;\n  private _panInput: PanInput | null;\n  private _stateMachine: StateMachine;\n\n  private _animatingContext: { start: number; end: number; offset: number };\n  private _dragged: boolean;\n\n  /**\n   * An {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance\n   * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes}의 인스턴스\n   * @type {Axes}\n   * @see https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html\n   * @readonly\n   */\n  public get axes() { return this._axes; }\n  /**\n   * @internal\n   */\n  public get stateMachine() { return this._stateMachine; }\n  /**\n   * A activated {@link State} that shows the current status of the user input or the animation\n   * @ko 현재 활성화된 {@link State} 인스턴스로 사용자 입력 또는 애니메이션 상태를 나타냅니다\n   * @type {State}\n   */\n  public get state() { return this._stateMachine.state; }\n  /**\n   * A context of the current animation playing\n   * @ko 현재 재생중인 애니메이션 정보\n   * @type {object}\n   * @property {number} start A start position of the animation<ko>애니메이션 시작 지점</ko>\n   * @property {number} end A end position of the animation<ko>애니메이션 끝 지점</ko>\n   * @property {number} offset camera offset<ko>카메라 오프셋</ko>\n   * @readonly\n   */\n  public get animatingContext() { return this._animatingContext; }\n  /**\n   * A current control parameters of the Axes instance\n   * @ko 활성화된 현재 Axes 패러미터들\n   * @type {ControlParams}\n   */\n  public get controlParams(): ControlParams {\n    const axes = this._axes;\n\n    if (!axes) {\n      return {\n        range: { min: 0, max: 0 },\n        position: 0,\n        circular: false\n      };\n    }\n\n    const axis = axes.axis[AXES.POSITION_KEY];\n\n    return {\n      range: { min: axis.range![0], max: axis.range![1] },\n      circular: (axis.circular as boolean[])[0],\n      position: this.position\n    };\n  }\n\n  /**\n   * A Boolean indicating whether the user input is enabled\n   * @ko 현재 사용자 입력이 활성화되었는지를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public get enabled() { return this._panInput?.isEnable() ?? false; }\n  /**\n   * Current position value in {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance\n   * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} 인스턴스 내부의 현재 좌표 값\n   * @type {number}\n   * @readonly\n   */\n  public get position() { return this._axes?.get([AXES.POSITION_KEY])[AXES.POSITION_KEY] ?? 0; }\n  /**\n   * Current range value in {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance\n   * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} 인스턴스 내부의 현재 이동 범위 값\n   * @type {number[]}\n   * @readonly\n   */\n  public get range() { return this._axes?.axis[AXES.POSITION_KEY].range ?? [0, 0]; }\n  /**\n   * Actual bounce size(px)\n   * @ko 적용된 bounce 크기(px 단위)\n   * @type {number[]}\n   * @readonly\n   */\n  public get bounce() { return this._axes?.axis[AXES.POSITION_KEY].bounce as number[] | undefined; }\n\n  /** */\n  public constructor() {\n    this._resetInternalValues();\n    this._stateMachine = new StateMachine();\n  }\n\n  /**\n   * Initialize AxesController\n   * @ko AxesController를 초기화합니다\n   * @param {Flicking} flicking An instance of Flicking\n   * @chainable\n   * @return {this}\n   */\n  public init(flicking: Flicking): this {\n    this._flicking = flicking;\n\n    this._axes = new Axes({\n      [AXES.POSITION_KEY]: {\n        range: [0, 0],\n        circular: false,\n        bounce: [0, 0]\n      }\n    }, {\n      deceleration: flicking.deceleration,\n      interruptable: flicking.interruptable,\n      easing: flicking.easing\n    });\n    this._panInput = new PanInput(flicking.viewport.element, {\n      inputType: flicking.inputType,\n      iOSEdgeSwipeThreshold: flicking.iOSEdgeSwipeThreshold,\n      scale: flicking.horizontal ? [-1, 0] : [0, -1],\n      releaseOnScroll: true\n    });\n\n    const axes = this._axes;\n\n    axes.connect(flicking.horizontal ? [AXES.POSITION_KEY, \"\"] : [\"\", AXES.POSITION_KEY], this._panInput);\n\n    for (const key in AXES.EVENT) {\n      const eventType = AXES.EVENT[key] as keyof AxesEvents;\n\n      axes.on(eventType, (e: AxesEvents[typeof eventType]) => {\n        this._stateMachine.fire(eventType, {\n          flicking,\n          axesEvent: e\n        });\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Destroy AxesController and return to initial state\n   * @ko AxesController를 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy(): void {\n    if (this._axes) {\n      this.removePreventClickHandler();\n      this._axes.destroy();\n    }\n\n    this._panInput?.destroy();\n\n    this._resetInternalValues();\n  }\n\n  /**\n   * Enable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 활성화합니다\n   * @chainable\n   * @return {this}\n   */\n  public enable(): this {\n    this._panInput?.enable();\n\n    return this;\n  }\n\n  /**\n   * Disable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 막습니다\n   * @chainable\n   * @return {this}\n   */\n  public disable(): this {\n    this._panInput?.disable();\n\n    return this;\n  }\n\n  /**\n   * Update {@link https://naver.github.io/egjs-axes/ @egjs/axes}'s state\n   * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 상태를 갱신합니다\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link AxesController#init init} is not called before\n   * <ko>{@link AxesController#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public update(controlParams: ControlParams): this {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n    const axes = this._axes!;\n    const axis = axes.axis[AXES.POSITION_KEY];\n\n    axis.circular = [controlParams.circular, controlParams.circular];\n    axis.range = [controlParams.range.min, controlParams.range.max];\n    axis.bounce = parseBounce(flicking.bounce, camera.size);\n\n    axes.axm.set({ [AXES.POSITION_KEY]: controlParams.position });\n\n    return this;\n  }\n\n  /**\n   * Attach a handler to the camera element to prevent click events during animation\n   * @ko 카메라 엘리먼트에 애니메이션 도중에 클릭 이벤트를 방지하는 핸들러를 부착합니다\n   * @return {this}\n   */\n  public addPreventClickHandler(): this {\n    const flicking = getFlickingAttached(this._flicking);\n    const axes = this._axes!;\n    const cameraEl = flicking.camera.element;\n\n    axes.on(AXES.EVENT.HOLD, this._onAxesHold);\n    axes.on(AXES.EVENT.CHANGE, this._onAxesChange);\n    cameraEl.addEventListener(\"click\", this._preventClickWhenDragged, true);\n\n    return this;\n  }\n\n  /**\n   * Detach a handler to the camera element to prevent click events during animation\n   * @ko 카메라 엘리먼트에 애니메이션 도중에 클릭 이벤트를 방지하는 핸들러를 탈착합니다\n   * @return {this}\n   */\n  public removePreventClickHandler(): this {\n    const flicking = getFlickingAttached(this._flicking);\n    const axes = this._axes!;\n    const cameraEl = flicking.camera.element;\n\n    axes.off(AXES.EVENT.HOLD, this._onAxesHold);\n    axes.off(AXES.EVENT.CHANGE, this._onAxesChange);\n    cameraEl.removeEventListener(\"click\", this._preventClickWhenDragged, true);\n\n    return this;\n  }\n\n  /**\n   * Run Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#setTo setTo} using the given position\n   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#setTo setTo} 메소드를 주어진 좌표를 이용하여 수행합니다\n   * @param {number} position A position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {number} [axesEvent] If provided, it'll use its {@link https://naver#github#io/egjs-axes/release/latest/doc/eg#Axes#html#setTo setTo} method instead<ko>이 값이 주어졌을 경우, 해당 이벤트의 {@link https://naver#github#io/egjs-axes/release/latest/doc/eg#Axes#html#setTo setTo} 메소드를 대신해서 사용합니다.</ko>\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public animateTo(position: number, duration: number, axesEvent?: OnRelease): Promise<void> {\n    const axes = this._axes;\n    const state = this._stateMachine.state;\n\n    if (!axes) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.NOT_ATTACHED_TO_FLICKING, ERROR.CODE.NOT_ATTACHED_TO_FLICKING));\n    }\n\n    const startPos = axes.get([AXES.POSITION_KEY])[AXES.POSITION_KEY];\n\n    if (startPos === position) {\n      const flicking = getFlickingAttached(this._flicking);\n\n      flicking.camera.lookAt(position);\n\n      if (state.targetPanel) {\n        flicking.control.setActive(state.targetPanel, flicking.control.activePanel, axesEvent?.isTrusted ?? false);\n      }\n      return Promise.resolve();\n    }\n\n    this._animatingContext = {\n      start: startPos,\n      end: position,\n      offset: 0\n    };\n\n    const animate = () => {\n      const resetContext = () => {\n        this._animatingContext = { start: 0, end: 0, offset: 0 };\n      };\n\n      axes.once(AXES.EVENT.FINISH, resetContext);\n\n      if (axesEvent) {\n        axesEvent.setTo({ [AXES.POSITION_KEY]: position }, duration);\n      } else {\n        axes.setTo({ [AXES.POSITION_KEY]: position }, duration);\n      }\n    };\n\n    if (duration === 0) {\n      const flicking = getFlickingAttached(this._flicking);\n      const camera = flicking.camera;\n\n      animate();\n\n      const newPos = flicking.circularEnabled\n        ? circulatePosition(position, camera.range.min, camera.range.max)\n        : position;\n\n      axes.axm.set({ [AXES.POSITION_KEY]: newPos });\n\n      return Promise.resolve();\n    } else {\n      return new Promise((resolve, reject) => {\n        const animationFinishHandler = () => {\n          axes.off(AXES.EVENT.HOLD, interruptionHandler);\n          resolve();\n        };\n\n        const interruptionHandler = () => {\n          axes.off(AXES.EVENT.FINISH, animationFinishHandler);\n          reject(new FlickingError(ERROR.MESSAGE.ANIMATION_INTERRUPTED, ERROR.CODE.ANIMATION_INTERRUPTED));\n        };\n\n        axes.once(AXES.EVENT.FINISH, animationFinishHandler);\n        axes.once(AXES.EVENT.HOLD, interruptionHandler);\n\n        animate();\n      });\n    }\n  }\n\n  private _resetInternalValues() {\n    this._flicking = null;\n    this._axes = null;\n    this._panInput = null;\n    this._animatingContext = { start: 0, end: 0, offset: 0 };\n    this._dragged = false;\n  }\n\n  private _onAxesHold = () => {\n    this._dragged = false;\n  };\n\n  private _onAxesChange = () => {\n    this._dragged = true;\n  };\n\n  private _preventClickWhenDragged = (e: MouseEvent) => {\n    if (this._dragged) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    this._dragged = false;\n  };\n}\n\nexport default AxesController;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport Flicking from \"../Flicking\";\nimport FlickingError from \"../core/FlickingError\";\nimport Panel from \"../core/panel/Panel\";\nimport AxesController from \"../control/AxesController\";\nimport { DIRECTION, EVENTS } from \"../const/external\";\nimport * as ERROR from \"../const/error\";\nimport { getDirection, getFlickingAttached } from \"../utils\";\nimport { ValueOf } from \"../type/internal\";\n\n/**\n * A component that manages inputs and animation of Flicking\n * @ko Flicking의 입력 장치 & 애니메이션을 담당하는 컴포넌트\n */\nabstract class Control {\n  // Internal States\n  protected _flicking: Flicking | null;\n  protected _controller: AxesController;\n  protected _activePanel: Panel | null;\n\n  /**\n   * A controller that handles the {@link https://naver.github.io/egjs-axes/ @egjs/axes} events\n   * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 이벤트를 처리하는 컨트롤러 컴포넌트\n   * @type {AxesController}\n   * @readonly\n   */\n  public get controller() { return this._controller; }\n  /**\n   * Index number of the {@link Flicking#currentPanel currentPanel}\n   * @ko {@link Flicking#currentPanel currentPanel}의 인덱스 번호\n   * @type {number}\n   * @default 0\n   * @readonly\n   */\n  public get activeIndex() { return this._activePanel?.index ?? -1; }\n  /**\n   * An active panel\n   * @ko 현재 선택된 패널\n   * @type {Panel | null}\n   * @readonly\n   */\n  public get activePanel() { return this._activePanel; }\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public get animating() { return this._controller.state.animating; }\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public get holding() { return this._controller.state.holding; }\n\n  /** */\n  public constructor() {\n    this._flicking = null;\n    this._controller = new AxesController();\n    this._activePanel = null;\n  }\n\n  /**\n   * Move {@link Camera} to the given position\n   * @ko {@link Camera}를 주어진 좌표로 이동합니다\n   * @method\n   * @abstract\n   * @memberof Control\n   * @instance\n   * @name moveToPosition\n   * @param {number} position The target position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public abstract moveToPosition(position: number, duration: number, axesEvent?: OnRelease): Promise<void>;\n\n  /**\n   * Initialize Control\n   * @ko Control을 초기화합니다\n   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking의 인스턴스</ko>\n   * @chainable\n   * @return {this}\n   */\n  public init(flicking: Flicking): this {\n    this._flicking = flicking;\n    this._controller.init(flicking);\n\n    return this;\n  }\n\n  /**\n   * Destroy Control and return to initial state\n   * @ko Control을 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy(): void {\n    this._controller.destroy();\n\n    this._flicking = null;\n    this._activePanel = null;\n  }\n\n  /**\n   * Enable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 활성화합니다\n   * @chainable\n   * @return {this}\n   */\n  public enable(): this {\n    this._controller.enable();\n\n    return this;\n  }\n\n  /**\n   * Disable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 막습니다\n   * @chainable\n   * @return {this}\n   */\n  public disable(): this {\n    this._controller.disable();\n\n    return this;\n  }\n\n  /**\n   * Update position after resizing\n   * @ko resize 이후에 position을 업데이트합니다\n   * @param {number} progressInPanel Previous camera's progress in active panel before resize<ko>Resize 이전 현재 선택된 패널 내에서의 카메라 progress 값</ko>\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @chainable\n   * @return {Promise<void>}\n   */\n  public updatePosition(_progressInPanel: number): void { // eslint-disable-line @typescript-eslint/no-unused-vars\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n\n    if (activePanel) {\n      camera.lookAt(camera.clampToReachablePosition(activePanel.position));\n    }\n  }\n\n  /**\n   * Update {@link Control#controller controller}'s state\n   * @ko {@link Control#controller controller}의 내부 상태를 갱신합니다\n   * @chainable\n   * @return {this}\n   */\n  public updateInput(): this {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n\n    this._controller.update(camera.controlParams);\n\n    return this;\n  }\n\n  /**\n   * Reset {@link Control#activePanel activePanel} to `null`\n   * @ko {@link Control#activePanel activePanel}을 `null`로 초기화합니다\n   * @chainable\n   * @return {this}\n   */\n  public resetActive(): this {\n    this._activePanel = null;\n\n    return this;\n  }\n\n  /**\n   * Move {@link Camera} to the given panel\n   * @ko {@link Camera}를 해당 패널 위로 이동합니다\n   * @param {Panel} panel The target panel to move<ko>이동할 패널</ko>\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @param {DIRECTION} [direction=DIRECTION.NONE] Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target panel<ko>해당 패널 도달시에 resolve되는 Promise</ko>\n   */\n  public async moveToPanel(panel: Panel, {\n    duration,\n    direction = DIRECTION.NONE,\n    axesEvent\n  }: {\n    duration: number;\n    direction?: ValueOf<typeof DIRECTION>;\n    axesEvent?: OnRelease;\n  }) {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n\n    let position = panel.position;\n    const nearestAnchor = camera.findNearestAnchor(position);\n\n    if (panel.removed || !nearestAnchor) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(panel.position), ERROR.CODE.POSITION_NOT_REACHABLE));\n    }\n    if (!camera.canReach(panel)) {\n      // Override position & panel if that panel is not reachable\n      position = nearestAnchor.position;\n      panel = nearestAnchor.panel;\n    } else if (flicking.circularEnabled) {\n      // Circular mode is enabled, find nearest distance to panel\n      const camPos = this._controller.position; // Actual position of the Axes\n      const camRangeDiff = camera.rangeDiff;\n      const possiblePositions = [position, position + camRangeDiff, position - camRangeDiff]\n        .filter(pos => {\n          if (direction === DIRECTION.NONE) return true;\n\n          return direction === DIRECTION.PREV\n            ? pos <= camPos\n            : pos >= camPos;\n        });\n\n      position = possiblePositions.reduce((nearestPosition, pos) => {\n        if (Math.abs(camPos - pos) < Math.abs(camPos - nearestPosition)) {\n          return pos;\n        } else {\n          return nearestPosition;\n        }\n      }, Infinity);\n    }\n\n    this._triggerIndexChangeEvent(panel, panel.position, axesEvent);\n\n    return this._animateToPosition({ position, duration, newActivePanel: panel, axesEvent });\n  }\n\n  /**\n   * @internal\n   */\n  public setActive(newActivePanel: Panel, prevActivePanel: Panel | null, isTrusted: boolean) {\n    const flicking = getFlickingAttached(this._flicking);\n\n    this._activePanel = newActivePanel;\n\n    flicking.camera.updateAdaptiveHeight();\n\n    if (newActivePanel !== prevActivePanel) {\n      flicking.trigger(new ComponentEvent(EVENTS.CHANGED, {\n        index: newActivePanel.index,\n        panel: newActivePanel,\n        prevIndex: prevActivePanel?.index ?? -1,\n        prevPanel: prevActivePanel,\n        isTrusted,\n        direction: prevActivePanel ? getDirection(prevActivePanel.position, newActivePanel.position) : DIRECTION.NONE\n      }));\n    } else {\n      flicking.trigger(new ComponentEvent(EVENTS.RESTORED, {\n        isTrusted\n      }));\n    }\n  }\n\n  protected _triggerIndexChangeEvent(panel: Panel, position: number, axesEvent?: OnRelease): void {\n    const flicking = getFlickingAttached(this._flicking);\n    const triggeringEvent = panel !== this._activePanel ? EVENTS.WILL_CHANGE : EVENTS.WILL_RESTORE;\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n\n    const event = new ComponentEvent(triggeringEvent, {\n      index: panel.index,\n      panel,\n      isTrusted: axesEvent?.isTrusted || false,\n      direction: getDirection(activePanel?.position ?? camera.position, position)\n    });\n    flicking.trigger(event);\n\n    if (event.isCanceled()) {\n      throw new FlickingError(ERROR.MESSAGE.STOP_CALLED_BY_USER, ERROR.CODE.STOP_CALLED_BY_USER);\n    }\n  }\n\n  protected async _animateToPosition({\n    position,\n    duration,\n    newActivePanel,\n    axesEvent\n  }: {\n    position: number;\n    duration: number;\n    newActivePanel: Panel;\n    axesEvent?: OnRelease;\n  }) {\n    const flicking = getFlickingAttached(this._flicking);\n    const animate = () => this._controller.animateTo(position, duration, axesEvent);\n    const state = this._controller.state;\n\n    state.targetPanel = newActivePanel;\n\n    if (duration <= 0) {\n      return animate();\n    } else {\n      return animate().then(async () => {\n        await flicking.renderer.render();\n      }).catch(err => {\n        if (axesEvent && err instanceof FlickingError && err.code === ERROR.CODE.ANIMATION_INTERRUPTED) return;\n        throw err;\n      });\n    }\n  }\n}\n\nexport default Control;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel from \"./panel/Panel\";\n\n/**\n * A data component that has actual position where the camera should be stopped at\n * @ko 카메라가 정지해야하는 실제 위치를 담고 있는 데이터 컴포넌트\n */\nclass AnchorPoint {\n  private _index: number;\n  private _pos: number;\n  private _panel: Panel;\n\n  /**\n   * Index of AnchorPoint\n   * @ko AnchorPoint의 인덱스\n   * @type {number}\n   * @readonly\n   */\n  public get index() { return this._index; }\n  /**\n   * Position of AnchorPoint\n   * @ko AnchorPoint의 좌표\n   * @type {number}\n   * @readonly\n   */\n  public get position() { return this._pos; }\n  /**\n   * A {@link Panel} instance AnchorPoint is referencing to\n   * @ko AnchorPoint가 참조하고 있는 {@link Panel}\n   * @type {Panel}\n   * @readonly\n   */\n  public get panel() { return this._panel; }\n\n  /**\n   * @param {object} options An options object<ko>옵션 객체</ko>\n   * @param {number} [options.index] Index of AnchorPoint<ko>AnchorPoint의 인덱스</ko>\n   * @param {number} [options.position] Position of AnchorPoint<ko>AnchorPoint의 좌표</ko>\n   * @param {Panel} [options.panel] A {@link Panel} instance AnchorPoint is referencing to<ko>AnchorPoint가 참조하고 있는 {@link Panel}</ko>\n   */\n  public constructor({\n    index,\n    position,\n    panel\n  }: {\n    index: number;\n    position: number;\n    panel: Panel;\n  }) {\n    this._index = index;\n    this._pos = position;\n    this._panel = panel;\n  }\n}\n\nexport default AnchorPoint;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\n\nimport FlickingError from \"../core/FlickingError\";\nimport AnchorPoint from \"../core/AnchorPoint\";\nimport { circulateIndex, clamp, getFlickingAttached } from \"../utils\";\nimport * as AXES from \"../const/axes\";\nimport * as ERROR from \"../const/error\";\n\nimport Control from \"./Control\";\n\n/**\n * An options for the {@link SnapControl}\n * @ko {@link SnapControl} 생성시 사용되는 옵션\n * @interface\n * @property {number} count Maximum number of panels can go after release<ko>입력 중단 이후 통과하여 이동할 수 있는 패널의 최대 갯수</ko>\n */\nexport interface SnapControlOptions {\n  count: number;\n}\n\n/**\n * A {@link Control} that uses a release momentum to choose destination panel\n * @ko 입력을 중단한 시점의 가속도에 영향받아 도달할 패널을 계산하는 이동 방식을 사용하는 {@link Control}\n */\nclass SnapControl extends Control {\n  private _count: SnapControlOptions[\"count\"];\n\n  /**\n   * Maximum number of panels can go after release\n   * @ko 입력 중단 이후 통과하여 이동할 수 있는 패널의 최대 갯수\n   * @type {number}\n   * @default Infinity\n   */\n  public get count() { return this._count; }\n\n  public set count(val: SnapControlOptions[\"count\"]) { this._count = val; }\n\n  /** */\n  public constructor({\n    count = Infinity\n  }: Partial<SnapControlOptions> = {}) {\n    super();\n\n    this._count = count;\n  }\n\n  /**\n   * Move {@link Camera} to the given position\n   * @ko {@link Camera}를 주어진 좌표로 이동합니다\n   * @param {number} position The target position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public async moveToPosition(position: number, duration: number, axesEvent?: OnRelease) {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n    const activeAnchor = camera.findActiveAnchor();\n    const anchorAtCamera = camera.findNearestAnchor(camera.position);\n    const state = flicking.control.controller.state;\n\n    if (!activeAnchor || !anchorAtCamera) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(position), ERROR.CODE.POSITION_NOT_REACHABLE));\n    }\n\n    const snapThreshold = this._calcSnapThreshold(position, activeAnchor);\n\n    const posDelta = flicking.animating\n      ? state.delta\n      : position - camera.position;\n    const absPosDelta = Math.abs(posDelta);\n    const snapDelta = axesEvent && axesEvent.delta[AXES.POSITION_KEY] !== 0\n      ? Math.abs(axesEvent.delta[AXES.POSITION_KEY])\n      : absPosDelta;\n    let targetAnchor: AnchorPoint;\n\n    if (snapDelta >= snapThreshold && snapDelta > 0) {\n      // Move to anchor at position\n      targetAnchor = this._findSnappedAnchor(position, anchorAtCamera);\n    } else if (absPosDelta >= flicking.threshold && absPosDelta > 0) {\n      // Move to the adjacent panel\n      targetAnchor = this._findAdjacentAnchor(posDelta, anchorAtCamera);\n    } else {\n      // Restore to active panel\n      targetAnchor = anchorAtCamera;\n    }\n\n    this._triggerIndexChangeEvent(targetAnchor.panel, position, axesEvent);\n\n    return this._animateToPosition({\n      position: camera.clampToReachablePosition(targetAnchor.position),\n      duration,\n      newActivePanel: targetAnchor.panel,\n      axesEvent\n    });\n  }\n\n  private _findSnappedAnchor(position: number, anchorAtCamera: AnchorPoint): AnchorPoint {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n    const count = this._count;\n\n    const currentPos = camera.position;\n\n    const clampedPosition = camera.clampToReachablePosition(position);\n    const anchorAtPosition = camera.findAnchorIncludePosition(clampedPosition);\n\n    if (!anchorAtCamera || !anchorAtPosition) {\n      throw new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(position), ERROR.CODE.POSITION_NOT_REACHABLE);\n    }\n\n    if (!isFinite(count)) {\n      return anchorAtPosition;\n    }\n\n    const panelCount = flicking.panelCount;\n    const anchors = camera.anchorPoints;\n\n    let loopCount = Math.sign(position - currentPos) * Math.floor(Math.abs(position - currentPos) / camera.rangeDiff);\n    if ((position > currentPos && anchorAtPosition.index < anchorAtCamera.index)\n      || (anchorAtPosition.position > anchorAtCamera.position && anchorAtPosition.index === anchorAtCamera.index)) {\n      loopCount += 1;\n    } else if ((position < currentPos && anchorAtPosition.index > anchorAtCamera.index)\n      || (anchorAtPosition.position < anchorAtCamera.position && anchorAtPosition.index === anchorAtCamera.index)) {\n      loopCount -= 1;\n    }\n\n    const circularIndexOffset = loopCount * panelCount;\n    const anchorAtPositionIndex = anchorAtPosition.index + circularIndexOffset;\n\n    if (Math.abs(anchorAtPositionIndex - anchorAtCamera.index) <= count) {\n      const anchor = anchors[anchorAtPosition.index];\n\n      return new AnchorPoint({\n        index: anchor.index,\n        position: anchor.position + loopCount * camera.rangeDiff,\n        panel: anchor.panel\n      });\n    }\n\n    if (flicking.circularEnabled) {\n      const targetAnchor = anchors[circulateIndex(anchorAtCamera.index + Math.sign(position - currentPos) * count, panelCount)];\n      let loop = Math.floor(count / panelCount);\n\n      if (position > currentPos && targetAnchor.index < anchorAtCamera.index) {\n        loop += 1;\n      } else if (position < currentPos && targetAnchor.index > anchorAtCamera.index) {\n        loop -= 1;\n      }\n\n      return new AnchorPoint({\n        index: targetAnchor.index,\n        position: targetAnchor.position + loop * camera.rangeDiff,\n        panel: targetAnchor.panel\n      });\n    } else {\n      return anchors[clamp(anchorAtCamera.index + Math.sign(position - currentPos) * count, 0, anchors.length - 1)];\n    }\n  }\n\n  private _findAdjacentAnchor(posDelta: number, anchorAtCamera: AnchorPoint): AnchorPoint {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n    const adjacentAnchor = (posDelta > 0 ? camera.getNextAnchor(anchorAtCamera) : camera.getPrevAnchor(anchorAtCamera)) ?? anchorAtCamera;\n\n    return adjacentAnchor;\n  }\n\n  private _calcSnapThreshold(position: number, activeAnchor: AnchorPoint): number {\n    const isNextDirection = position > activeAnchor.position;\n    const panel = activeAnchor.panel;\n    const panelSize = panel.size;\n    const alignPos = panel.alignPosition;\n\n    // Minimum distance needed to decide prev/next panel as nearest\n    /*\n     * |  Prev  |     Next     |\n     * |<------>|<------------>|\n     * [        |<-Anchor      ]\n     */\n    return isNextDirection\n      ? panelSize - alignPos + panel.margin.next\n      : alignPos + panel.margin.prev;\n  }\n}\n\nexport default SnapControl;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\n\nimport FlickingError from \"../core/FlickingError\";\nimport * as ERROR from \"../const/error\";\nimport { getFlickingAttached } from \"../utils\";\n\nimport Control from \"./Control\";\n\n/**\n * An options for the {@link FreeControl}\n * @ko {@link FreeControl} 생성시 사용되는 옵션\n * @interface\n * @property {boolean} stopAtEdge Make scroll animation to stop at the start/end of the scroll area, not going out the bounce area\n * <ko>스크롤 애니메이션을 스크롤 영역의 시작과 끝부분에서 멈추도록 하여, 바운스 영역을 넘어가지 않도록 합니다</ko>\n */\nexport interface FreeControlOptions {\n  stopAtEdge: boolean;\n}\n\n/**\n * A {@link Control} that can be scrolled freely without alignment\n * @ko 패널이 정해진 지점에 정렬되지 않고, 자유롭게 스크롤할 수 있는 이동 방식을 사용하는 {@link Control}\n */\nclass FreeControl extends Control {\n  private _stopAtEdge: FreeControlOptions[\"stopAtEdge\"];\n\n  /**\n   * Make scroll animation to stop at the start/end of the scroll area, not going out the bounce area\n   * @ko 스크롤 애니메이션을 스크롤 영역의 시작과 끝부분에서 멈추도록 하여, 바운스 영역을 넘어가지 않도록 합니다\n   * @type {boolean}\n   * @default true\n   */\n  public get stopAtEdge() { return this._stopAtEdge; }\n\n  public set stopAtEdge(val: FreeControlOptions[\"stopAtEdge\"]) { this._stopAtEdge = val; }\n\n  /** */\n  public constructor({\n    stopAtEdge = true\n  }: Partial<FreeControlOptions> = {}) {\n    super();\n\n    this._stopAtEdge = stopAtEdge;\n  }\n\n  /**\n   * Update position after resizing\n   * @ko resize 이후에 position을 업데이트합니다\n   * @param {number} progressInPanel Previous camera's progress in active panel before resize<ko>Resize 이전 현재 선택된 패널 내에서의 카메라 progress 값</ko>\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @chainable\n   * @return {Promise<void>}\n   */\n  public updatePosition(progressInPanel: number): void {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n\n    if (activePanel) {\n      const panelRange = activePanel.range;\n      const newPosition = panelRange.min + (panelRange.max - panelRange.min) * progressInPanel;\n\n      camera.lookAt(camera.clampToReachablePosition(newPosition));\n    }\n  }\n\n  /**\n   * Move {@link Camera} to the given position\n   * @ko {@link Camera}를 주어진 좌표로 이동합니다\n   * @param {number} position The target position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public async moveToPosition(position: number, duration: number, axesEvent?: OnRelease) {\n    const flicking = getFlickingAttached(this._flicking);\n\n    const camera = flicking.camera;\n    const targetPos = camera.clampToReachablePosition(position);\n\n    const anchorAtPosition = camera.findAnchorIncludePosition(targetPos);\n\n    if (!anchorAtPosition) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(position), ERROR.CODE.POSITION_NOT_REACHABLE));\n    }\n\n    const targetPanel = anchorAtPosition.panel;\n\n    // Trigger only change event\n    if (targetPanel !== this._activePanel) {\n      this._triggerIndexChangeEvent(targetPanel, position, axesEvent);\n    }\n\n    return this._animateToPosition({ position: this._stopAtEdge ? targetPos : position, duration, newActivePanel: targetPanel, axesEvent });\n  }\n}\n\nexport default FreeControl;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { OnRelease } from \"@egjs/axes\";\n\nimport Panel from \"../core/panel/Panel\";\nimport FlickingError from \"../core/FlickingError\";\nimport { clamp, getFlickingAttached, getMinusCompensatedIndex, isBetween } from \"../utils\";\nimport * as ERROR from \"../const/error\";\n\nimport Control from \"./Control\";\n/**\n * An options for the {@link StrictControl}\n * @ko {@link StrictControl} 생성시 사용되는 옵션\n * @interface\n * @property {number} count Maximum number of panels that can be moved at a time<ko>최대로 움직일 수 있는 패널의 개수</ko>\n */\nexport interface StrictControlOptions {\n  count: number;\n}\n\n/**\n * A {@link Control} that allow you to select the maximum number of panels to move at a time\n * @ko 한번에 최대로 이동할 패널의 개수를 선택 가능한 {@link Control}\n */\nclass StrictControl extends Control {\n  private _count: number;\n  private _indexRange: { min: number; max: number };\n\n  /**\n   * Maximum number of panels that can be moved at a time\n   * @ko 최대로 움직일 수 있는 패널의 개수\n   * @type {number}\n   * @default 1\n   */\n  public get count() { return this._count; }\n\n  public set count(val: StrictControlOptions[\"count\"]) { this._count = val; }\n\n  /** */\n  public constructor({\n    count = 1\n  }: Partial<StrictControlOptions> = {}) {\n    super();\n\n    this._count = count;\n    this._resetIndexRange();\n  }\n\n  /**\n   * Destroy Control and return to initial state\n   * @ko Control을 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy() {\n    super.destroy();\n\n    this._resetIndexRange();\n  }\n\n  /**\n   * Update {@link Control#controller controller}'s state\n   * @ko {@link Control#controller controller}의 내부 상태를 갱신합니다\n   * @chainable\n   * @return {this}\n   */\n  public updateInput(): this {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n    const renderer = flicking.renderer;\n    const controller = this._controller;\n    const controlParams = camera.controlParams;\n    const count = this._count;\n\n    const activePanel = controller.state.animating\n      ? camera.findNearestAnchor(camera.position)?.panel\n      : this._activePanel;\n\n    if (!activePanel) {\n      controller.update(controlParams);\n      this._resetIndexRange();\n      return this;\n    }\n\n    const cameraRange = controlParams.range;\n    const currentPos = activePanel.position;\n    const currentIndex = activePanel.index;\n    const panelCount = renderer.panelCount;\n\n    let prevPanelIndex = currentIndex - count;\n    let nextPanelIndex = currentIndex + count;\n\n    if (prevPanelIndex < 0) {\n      prevPanelIndex = flicking.circularEnabled\n        ? getMinusCompensatedIndex((prevPanelIndex + 1) % panelCount - 1, panelCount)\n        : clamp(prevPanelIndex, 0, panelCount - 1);\n    }\n    if (nextPanelIndex >= panelCount) {\n      nextPanelIndex = flicking.circularEnabled\n        ? nextPanelIndex % panelCount\n        : clamp(nextPanelIndex, 0, panelCount - 1);\n    }\n\n    const prevPanel = renderer.panels[prevPanelIndex];\n    const nextPanel = renderer.panels[nextPanelIndex];\n\n    let prevPos = Math.max(prevPanel.position, cameraRange.min);\n    let nextPos = Math.min(nextPanel.position, cameraRange.max);\n\n    if (prevPos > currentPos) {\n      prevPos -= camera.rangeDiff;\n    }\n    if (nextPos < currentPos) {\n      nextPos += camera.rangeDiff;\n    }\n\n    controlParams.range = {\n      min: prevPos,\n      max: nextPos\n    };\n\n    if (controlParams.circular) {\n      if (controlParams.position < prevPos) {\n        controlParams.position += camera.rangeDiff;\n      }\n\n      if (controlParams.position > nextPos) {\n        controlParams.position -= camera.rangeDiff;\n      }\n    }\n\n    controlParams.circular = false;\n    controller.update(controlParams);\n\n    this._indexRange = {\n      min: prevPanel.index,\n      max: nextPanel.index\n    };\n\n    return this;\n  }\n\n  /**\n   * Move {@link Camera} to the given position\n   * @ko {@link Camera}를 주어진 좌표로 이동합니다\n   * @param {number} position The target position to move<ko>이동할 좌표</ko>\n   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}\n   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|\n   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>\n   */\n  public async moveToPosition(position: number, duration: number, axesEvent?: OnRelease) {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n    const activePanel = this._activePanel;\n    const axesRange = this._controller.range;\n    const indexRange = this._indexRange;\n    const cameraRange = camera.range;\n\n    const clampedPosition = clamp(camera.clampToReachablePosition(position), axesRange[0], axesRange[1]);\n    const anchorAtPosition = camera.findAnchorIncludePosition(clampedPosition);\n\n    if (!anchorAtPosition || !activePanel) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.POSITION_NOT_REACHABLE(position), ERROR.CODE.POSITION_NOT_REACHABLE));\n    }\n\n    const prevPos = activePanel.position;\n\n    const isOverThreshold = Math.abs(position - prevPos) >= flicking.threshold;\n    const adjacentAnchor = (position > prevPos)\n      ? camera.getNextAnchor(anchorAtPosition)\n      : camera.getPrevAnchor(anchorAtPosition);\n\n    let targetPos: number;\n    let targetPanel: Panel;\n\n    const anchors = camera.anchorPoints;\n    const firstAnchor = anchors[0];\n    const lastAnchor = anchors[anchors.length - 1];\n\n    const shouldBounceToFirst = position <= cameraRange.min && isBetween(firstAnchor.panel.index, indexRange.min, indexRange.max);\n    const shouldBounceToLast = position >= cameraRange.max && isBetween(lastAnchor.panel.index, indexRange.min, indexRange.max);\n\n    if (shouldBounceToFirst || shouldBounceToLast) {\n      // In bounce area\n      const targetAnchor = position < cameraRange.min ? firstAnchor : lastAnchor;\n\n      targetPanel = targetAnchor.panel;\n      targetPos = targetAnchor.position;\n    } else if (isOverThreshold && anchorAtPosition.position !== activePanel.position) {\n      // Move to anchor at position\n      targetPanel = anchorAtPosition.panel;\n      targetPos = anchorAtPosition.position;\n    } else if (isOverThreshold && adjacentAnchor && isBetween(adjacentAnchor.index, indexRange.min, indexRange.max)) {\n      // Move to adjacent anchor\n      targetPanel = adjacentAnchor.panel;\n      targetPos = adjacentAnchor.position;\n    } else {\n      // Restore to active panel\n      targetPos = camera.clampToReachablePosition(activePanel.position);\n      targetPanel = activePanel;\n    }\n\n    this._triggerIndexChangeEvent(targetPanel, position, axesEvent);\n\n    return this._animateToPosition({\n      position: targetPos,\n      duration,\n      newActivePanel: targetPanel,\n      axesEvent\n    });\n  }\n\n  public setActive = (newActivePanel: Panel, prevActivePanel: Panel | null, isTrusted: boolean) => {\n    super.setActive(newActivePanel, prevActivePanel, isTrusted);\n    this.updateInput();\n  };\n\n  private _resetIndexRange() {\n    this._indexRange = { min: 0, max: 0 };\n  }\n}\n\nexport default StrictControl;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../../Flicking\";\nimport Panel from \"../../core/panel/Panel\";\nimport AnchorPoint from \"../../core/AnchorPoint\";\nimport { clamp } from \"../../utils\";\n\n/**\n * A mode of camera\n */\nabstract class CameraMode {\n  protected _flicking: Flicking;\n\n  /** */\n  public constructor(flicking: Flicking) {\n    this._flicking = flicking;\n  }\n\n  public abstract checkAvailability(): boolean;\n  public abstract getRange(): { min: number; max: number };\n\n  public getAnchors(): AnchorPoint[] {\n    const panels = this._flicking.renderer.panels;\n\n    return panels.map((panel, index) => new AnchorPoint({\n      index,\n      position: panel.position,\n      panel\n    }));\n  }\n\n  public findAnchorIncludePosition(position: number): AnchorPoint | null {\n    const anchors = this._flicking.camera.anchorPoints;\n    const anchorsIncludingPosition = anchors.filter(anchor => anchor.panel.includePosition(position, true));\n\n    return anchorsIncludingPosition.reduce((nearest: AnchorPoint | null, anchor) => {\n      if (!nearest) return anchor;\n\n      return Math.abs(nearest.position - position) < Math.abs(anchor.position - position)\n        ? nearest\n        : anchor;\n    }, null);\n  }\n\n  public clampToReachablePosition(position: number): number {\n    const camera = this._flicking.camera;\n    const range = camera.range;\n\n    return clamp(position, range.min, range.max);\n  }\n\n  public getCircularOffset(): number {\n    return 0;\n  }\n\n  public canReach(panel: Panel): boolean {\n    const camera = this._flicking.camera;\n    const range = camera.range;\n\n    if (panel.removed) return false;\n\n    const panelPos = panel.position;\n\n    return panelPos >= range.min && panelPos <= range.max;\n  }\n\n  public canSee(panel: Panel): boolean {\n    const camera = this._flicking.camera;\n    const visibleRange = camera.visibleRange;\n    // Should not include margin, as we don't declare what the margin is visible as what the panel is visible.\n    return panel.isVisibleOnRange(visibleRange.min, visibleRange.max);\n  }\n}\n\nexport default CameraMode;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport CameraMode from \"./CameraMode\";\n\nclass LinearCameraMode extends CameraMode {\n  public checkAvailability(): boolean {\n    // It's always available\n    return true;\n  }\n\n  public getRange(): { min: number; max: number } {\n    const renderer = this._flicking.renderer;\n\n    const firstPanel = renderer.getPanel(0);\n    const lastPanel = renderer.getPanel(renderer.panelCount - 1);\n\n    return { min: firstPanel?.position ?? 0, max: lastPanel?.position ?? 0 };\n  }\n}\n\nexport default LinearCameraMode;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel from \"../../core/panel/Panel\";\nimport AnchorPoint from \"../../core/AnchorPoint\";\nimport { DIRECTION } from \"../../const/external\";\nimport { circulatePosition } from \"../../utils\";\n\nimport CameraMode from \"./CameraMode\";\n\n/**\n * A {@link Camera} mode that connects the last panel and the first panel, enabling continuous loop\n * @ko 첫번째 패널과 마지막 패널이 이어진 상태로, 무한히 회전할 수 있는 종류의 {@link Camera} 모드\n */\nclass CircularCameraMode extends CameraMode {\n  public checkAvailability(): boolean {\n    const flicking = this._flicking;\n    const renderer = flicking.renderer;\n    const panels = renderer.panels;\n\n    if (panels.length <= 0) {\n      return false;\n    }\n\n    const firstPanel = panels[0];\n    const lastPanel = panels[panels.length - 1];\n    const firstPanelPrev = firstPanel.range.min - firstPanel.margin.prev;\n    const lastPanelNext = lastPanel.range.max + lastPanel.margin.next;\n\n    const visibleSize = flicking.camera.size;\n    const panelSizeSum = lastPanelNext - firstPanelPrev;\n\n    const canSetCircularMode = panels\n      .every(panel => panelSizeSum - panel.size >= visibleSize);\n\n    return canSetCircularMode;\n  }\n\n  public getRange(): { min: number; max: number } {\n    const flicking = this._flicking;\n    const panels = flicking.renderer.panels;\n\n    if (panels.length <= 0) {\n      return { min: 0, max: 0 };\n    }\n\n    const firstPanel = panels[0];\n    const lastPanel = panels[panels.length - 1];\n    const firstPanelPrev = firstPanel.range.min - firstPanel.margin.prev;\n    const lastPanelNext = lastPanel.range.max + lastPanel.margin.next;\n\n    return { min: firstPanelPrev, max: lastPanelNext };\n  }\n\n  public getAnchors(): AnchorPoint[] {\n    const flicking = this._flicking;\n    const panels = flicking.renderer.panels;\n\n    return panels.map((panel, index) => new AnchorPoint({\n      index,\n      position: panel.position,\n      panel\n    }));\n  }\n\n  public findAnchorIncludePosition(position: number): AnchorPoint | null {\n    const camera = this._flicking.camera;\n    const range = camera.range;\n    const anchors = camera.anchorPoints;\n    const rangeDiff = camera.rangeDiff;\n    const anchorCount = anchors.length;\n    const positionInRange = circulatePosition(position, range.min, range.max);\n\n    let anchorInRange: AnchorPoint | null = super.findAnchorIncludePosition(positionInRange);\n\n    if (anchorCount > 0 && (position === range.min || position === range.max)) {\n      const possibleAnchors = [\n        anchorInRange,\n        new AnchorPoint({\n          index: 0,\n          position: anchors[0].position + rangeDiff,\n          panel: anchors[0].panel\n        }),\n        new AnchorPoint({\n          index: anchorCount - 1,\n          position: anchors[anchorCount - 1].position - rangeDiff,\n          panel: anchors[anchorCount - 1].panel\n        })\n      ].filter(anchor => !!anchor) as AnchorPoint[];\n\n      anchorInRange = possibleAnchors.reduce((nearest: AnchorPoint | null, anchor) => {\n        if (!nearest) return anchor;\n\n        return Math.abs(nearest.position - position) < Math.abs(anchor.position - position)\n          ? nearest\n          : anchor;\n      }, null);\n    }\n\n    if (!anchorInRange) return null;\n\n    if (position < range.min) {\n      const loopCount = -Math.floor((range.min - position) / rangeDiff) - 1;\n\n      return new AnchorPoint({\n        index: anchorInRange.index,\n        position: anchorInRange.position + rangeDiff * loopCount,\n        panel: anchorInRange.panel\n      });\n    } else if (position > range.max) {\n      const loopCount = Math.floor((position - range.max) / rangeDiff) + 1;\n\n      return new AnchorPoint({\n        index: anchorInRange.index,\n        position: anchorInRange.position + rangeDiff * loopCount,\n        panel: anchorInRange.panel\n      });\n    }\n\n    return anchorInRange;\n  }\n\n  public getCircularOffset(): number {\n    const flicking = this._flicking;\n    const camera = flicking.camera;\n\n    if (!camera.circularEnabled) return 0;\n\n    const toggled = flicking.panels.filter(panel => panel.toggled);\n    const toggledPrev = toggled.filter(panel => panel.toggleDirection === DIRECTION.PREV);\n    const toggledNext = toggled.filter(panel => panel.toggleDirection === DIRECTION.NEXT);\n\n    return this._calcPanelAreaSum(toggledPrev) - this._calcPanelAreaSum(toggledNext);\n  }\n\n  public clampToReachablePosition(position: number): number {\n    // Basically all position is reachable for circular camera\n    return position;\n  }\n\n  public canReach(panel: Panel): boolean {\n    if (panel.removed) return false;\n\n    // Always reachable on circular mode\n    return true;\n  }\n\n  public canSee(panel: Panel): boolean {\n    const camera = this._flicking.camera;\n    const range = camera.range;\n    const rangeDiff = camera.rangeDiff;\n    const visibleRange = camera.visibleRange;\n    const visibleInCurrentRange = super.canSee(panel);\n\n    // Check looped visible area for circular case\n    if (visibleRange.min < range.min) {\n      return visibleInCurrentRange || panel.isVisibleOnRange(visibleRange.min + rangeDiff, visibleRange.max + rangeDiff);\n    } else if (visibleRange.max > range.max) {\n      return visibleInCurrentRange || panel.isVisibleOnRange(visibleRange.min - rangeDiff, visibleRange.max - rangeDiff);\n    }\n\n    return visibleInCurrentRange;\n  }\n\n  private _calcPanelAreaSum(panels: Panel[]) {\n    return panels.reduce((sum: number, panel: Panel) => sum + panel.sizeIncludingMargin, 0);\n  }\n}\n\nexport default CircularCameraMode;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport AnchorPoint from \"../../core/AnchorPoint\";\nimport Panel from \"../../core/panel/Panel\";\nimport { parseAlign } from \"../../utils\";\n\nimport CameraMode from \"./CameraMode\";\n\nclass BoundCameraMode extends CameraMode {\n  public checkAvailability(): boolean {\n    const flicking = this._flicking;\n    const renderer = flicking.renderer;\n\n    const firstPanel = renderer.getPanel(0);\n    const lastPanel = renderer.getPanel(renderer.panelCount - 1);\n\n    if (!firstPanel || !lastPanel) {\n      return false;\n    }\n\n    const viewportSize = flicking.camera.size;\n    const firstPanelPrev = firstPanel.range.min;\n    const lastPanelNext = lastPanel.range.max;\n    const panelAreaSize = lastPanelNext - firstPanelPrev;\n    const isBiggerThanViewport = viewportSize < panelAreaSize;\n\n    return isBiggerThanViewport;\n  }\n\n  public getRange(): { min: number; max: number } {\n    const flicking = this._flicking;\n    const renderer = flicking.renderer;\n    const alignPos = flicking.camera.alignPosition;\n\n    const firstPanel = renderer.getPanel(0);\n    const lastPanel = renderer.getPanel(renderer.panelCount - 1);\n\n    if (!firstPanel || !lastPanel) {\n      return { min: 0, max: 0 };\n    }\n\n    const viewportSize = flicking.camera.size;\n    const firstPanelPrev = firstPanel.range.min;\n    const lastPanelNext = lastPanel.range.max;\n    const panelAreaSize = lastPanelNext - firstPanelPrev;\n    const isBiggerThanViewport = viewportSize < panelAreaSize;\n\n    const firstPos = firstPanelPrev + alignPos;\n    const lastPos = lastPanelNext - viewportSize + alignPos;\n\n    if (isBiggerThanViewport) {\n      return { min: firstPos, max: lastPos };\n    } else {\n      const align = flicking.camera.align;\n      const alignVal = typeof align === \"object\"\n        ? (align as { camera: string | number }).camera\n        : align;\n\n      const pos = firstPos + parseAlign(alignVal, lastPos - firstPos);\n\n      return { min: pos, max: pos };\n    }\n  }\n\n  public getAnchors(): AnchorPoint[] {\n    const flicking = this._flicking;\n    const camera = flicking.camera;\n    const panels = flicking.renderer.panels;\n\n    if (panels.length <= 0) {\n      return [];\n    }\n\n    const range = flicking.camera.range;\n    const reachablePanels = panels.filter(panel => camera.canReach(panel));\n\n    if (reachablePanels.length > 0) {\n      const shouldPrependBoundAnchor = reachablePanels[0].position !== range.min;\n      const shouldAppendBoundAnchor = reachablePanels[reachablePanels.length - 1].position !== range.max;\n      const indexOffset = shouldPrependBoundAnchor ? 1 : 0;\n\n      const newAnchors = reachablePanels.map((panel, idx) => new AnchorPoint({\n        index: idx + indexOffset,\n        position: panel.position,\n        panel\n      }));\n\n      if (shouldPrependBoundAnchor) {\n        newAnchors.splice(0, 0, new AnchorPoint({\n          index: 0,\n          position: range.min,\n          panel: panels[reachablePanels[0].index - 1]\n        }));\n      }\n\n      if (shouldAppendBoundAnchor) {\n        newAnchors.push(new AnchorPoint({\n          index: newAnchors.length,\n          position: range.max,\n          panel: panels[reachablePanels[reachablePanels.length - 1].index + 1]\n        }));\n      }\n\n      return newAnchors;\n    } else if (range.min !== range.max) {\n      // There're more than 2 panels\n      const nearestPanelAtMin = this._findNearestPanel(range.min, panels);\n      const panelAtMin = nearestPanelAtMin.index === panels.length - 1\n        ? nearestPanelAtMin.prev()!\n        : nearestPanelAtMin;\n      const panelAtMax = panelAtMin.next()!;\n\n      return [\n        new AnchorPoint({\n          index: 0,\n          position: range.min,\n          panel: panelAtMin\n        }),\n        new AnchorPoint({\n          index: 1,\n          position: range.max,\n          panel: panelAtMax\n        })\n      ];\n    } else {\n      return [new AnchorPoint({\n        index: 0,\n        position: range.min,\n        panel: this._findNearestPanel(range.min, panels)\n      })];\n    }\n  }\n\n  public findAnchorIncludePosition(position: number): AnchorPoint | null {\n    const camera = this._flicking.camera;\n    const range = camera.range;\n    const anchors = camera.anchorPoints;\n\n    if (anchors.length <= 0) return null;\n\n    if (position <= range.min) {\n      return anchors[0];\n    } else if (position >= range.max) {\n      return anchors[anchors.length - 1];\n    } else {\n      return super.findAnchorIncludePosition(position);\n    }\n  }\n\n  private _findNearestPanel(pos: number, panels: Panel[]): Panel {\n    let prevDist = Infinity;\n    for (let panelIdx = 0; panelIdx < panels.length; panelIdx++) {\n      const panel = panels[panelIdx];\n      const dist = Math.abs(panel.position - pos);\n\n      if (dist > prevDist) {\n        // Return previous anchor\n        return panels[panelIdx - 1];\n      }\n\n      prevDist = dist;\n    }\n\n    // Return last anchor\n    return panels[panels.length - 1];\n  }\n}\n\nexport default BoundCameraMode;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\n\nimport Flicking, { FlickingOptions } from \"../Flicking\";\nimport FlickingError from \"../core/FlickingError\";\nimport Panel from \"../core/panel/Panel\";\nimport AnchorPoint from \"../core/AnchorPoint\";\nimport * as ERROR from \"../const/error\";\nimport { ALIGN, CIRCULAR_FALLBACK, DIRECTION, EVENTS } from \"../const/external\";\nimport { checkExistence, find, getFlickingAttached, getProgress, includes, parseAlign, toArray } from \"../utils\";\n\nimport { CameraMode, BoundCameraMode, CircularCameraMode, LinearCameraMode } from \"./mode\";\n\nexport interface CameraOptions {\n  align: FlickingOptions[\"align\"];\n}\n\n/**\n * A component that manages actual movement inside the viewport\n * @ko 뷰포트 내에서의 실제 움직임을 담당하는 컴포넌트\n */\nclass Camera {\n  // Options\n  private _align: FlickingOptions[\"align\"];\n\n  // Internal states\n  private _flicking: Flicking | null;\n  private _mode: CameraMode;\n  private _el: HTMLElement;\n  private _transform: string;\n  private _position: number;\n  private _alignPos: number;\n  private _offset: number;\n  private _circularOffset: number;\n  private _circularEnabled: boolean;\n  private _range: { min: number; max: number };\n  private _visiblePanels: Panel[];\n  private _anchors: AnchorPoint[];\n  private _needPanelTriggered: { prev: boolean; next: boolean };\n\n  // Internal states getter\n  /**\n   * The camera element(`.flicking-camera`)\n   * @ko 카메라 엘리먼트(`.flicking-camera`)\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._el; }\n  /**\n   * An array of the child elements of the camera element(`.flicking-camera`)\n   * @ko 카메라 엘리먼트(`.flicking-camera`)의 자식 엘리먼트 배열\n   * @type {HTMLElement[]}\n   * @readonly\n   */\n  public get children() { return toArray(this._el.children) as HTMLElement[]; }\n  /**\n   * Current position of the camera\n   * @ko Camera의 현재 좌표\n   * @type {number}\n   * @readonly\n   */\n  public get position() { return this._position; }\n  /**\n   * Align position inside the viewport where {@link Panel}'s {@link Panel#alignPosition alignPosition} should be located at\n   * @ko 패널의 정렬 기준 위치. 뷰포트 내에서 {@link Panel}의 {@link Panel#alignPosition alignPosition}이 위치해야 하는 곳입니다\n   * @type {number}\n   * @readonly\n   */\n  public get alignPosition() { return this._alignPos; }\n  /**\n   * Position offset, used for the {@link Flicking#renderOnlyVisible renderOnlyVisible} option\n   * @ko Camera의 좌표 오프셋. {@link Flicking#renderOnlyVisible renderOnlyVisible} 옵션을 위해 사용됩니다.\n   * @type {number}\n   * @default 0\n   * @readonly\n   */\n  public get offset() { return this._offset - this._circularOffset; }\n  /**\n   * Whether the `circular` option is enabled.\n   * The {@link Flicking#circular circular} option can't be enabled when sum of the panel sizes are too small.\n   * @ko {@link Flicking#circular circular} 옵션이 활성화되었는지 여부를 나타내는 멤버 변수.\n   * {@link Flicking#circular circular} 옵션은 패널의 크기의 합이 충분하지 않을 경우 비활성화됩니다.\n   * @type {boolean}\n   * @default false\n   * @readonly\n   */\n  public get circularEnabled() { return this._circularEnabled; }\n  /**\n   * A current camera mode\n   * @type {CameraMode}\n   * @readonly\n   */\n  public get mode() { return this._mode; }\n  /**\n   * A range that Camera's {@link Camera#position position} can reach\n   * @ko Camera의 {@link Camera#position position}이 도달 가능한 범위\n   * @type {object}\n   * @property {number} min A minimum position<ko>최소 위치</ko>\n   * @property {number} max A maximum position<ko>최대 위치</ko>\n   * @readonly\n   */\n  public get range() { return this._range; }\n  /**\n   * A difference between Camera's minimum and maximum position that can reach\n   * @ko Camera가 도달 가능한 최소/최대 좌표의 차이\n   * @type {number}\n   * @readonly\n   */\n  public get rangeDiff() { return this._range.max - this._range.min; }\n  /**\n   * An array of visible panels from the current position\n   * @ko 현재 보이는 패널들의 배열\n   * @type {Panel[]}\n   * @readonly\n   */\n  public get visiblePanels() { return this._visiblePanels; }\n  /**\n   * A range of the visible area from the current position\n   * @ko 현재 위치에서 보이는 범위\n   * @type {object}\n   * @property {number} min A minimum position<ko>최소 위치</ko>\n   * @property {number} min A maximum position<ko>최대 위치</ko>\n   * @readonly\n   */\n  public get visibleRange() { return { min: this._position - this._alignPos, max: this._position - this._alignPos + this.size }; }\n  /**\n   * An array of {@link AnchorPoint}s that Camera can be stopped at\n   * @ko 카메라가 도달 가능한 {@link AnchorPoint}의 목록\n   * @type {AnchorPoint[]}\n   * @readonly\n   */\n  public get anchorPoints() { return this._anchors; }\n  /**\n   * A current parameters of the Camera for updating {@link AxesController}\n   * @ko {@link AxesController}를 업데이트하기 위한 현재 Camera 패러미터들\n   * @type {ControlParams}\n   * @readonly\n   */\n  public get controlParams() { return { range: this._range, position: this._position, circular: this._circularEnabled }; }\n  /**\n   * A Boolean value indicating whether Camera's over the minimum or maximum position reachable\n   * @ko 현재 카메라가 도달 가능한 범위의 최소 혹은 최대점을 넘어섰는지를 나타냅니다\n   * @type {boolean}\n   * @readonly\n   */\n  public get atEdge() { return this._position <= this._range.min || this._position >= this._range.max; }\n  /**\n   * Return the size of the viewport\n   * @ko 뷰포트 크기를 반환합니다\n   * @type {number}\n   * @readonly\n   */\n  public get size() {\n    const flicking = this._flicking;\n    return flicking\n      ? flicking.horizontal\n        ? flicking.viewport.width\n        : flicking.viewport.height\n      : 0;\n  }\n\n  /**\n   * Return the camera's position progress from the first panel to last panel\n   * Range is from 0 to last panel's index\n   * @ko 첫번째 패널로부터 마지막 패널까지의 카메라 위치의 진행도를 반환합니다\n   * 범위는 0부터 마지막 패널의 인덱스까지입니다\n   * @type {number}\n   * @readonly\n   */\n  public get progress() {\n    const flicking = this._flicking;\n    const position = this._position + this._offset;\n    const nearestAnchor = this.findNearestAnchor(this._position);\n\n    if (!flicking || !nearestAnchor) {\n      return NaN;\n    }\n\n    const nearestPanel = nearestAnchor.panel;\n    const panelPos = nearestPanel.position + nearestPanel.offset;\n    const bounceSize = flicking.control.controller.bounce!;\n\n    const { min: prevRange, max: nextRange } = this.range;\n    const rangeDiff = this.rangeDiff;\n\n    if (position === panelPos) {\n      return nearestPanel.index;\n    }\n\n    if (position < panelPos) {\n      const prevPanel = nearestPanel.prev();\n      let prevPosition = prevPanel\n        ? prevPanel.position + prevPanel.offset\n        : prevRange - bounceSize[0];\n\n      // Looped\n      if (prevPosition > panelPos) {\n        prevPosition -= rangeDiff;\n      }\n\n      return nearestPanel.index - 1 + getProgress(position, prevPosition, panelPos);\n    } else {\n      const nextPanel = nearestPanel.next();\n      let nextPosition = nextPanel\n        ? nextPanel.position + nextPanel.offset\n        : nextRange + bounceSize[1];\n\n      // Looped\n      if (nextPosition < panelPos) {\n        nextPosition += rangeDiff;\n      }\n\n      return nearestPanel.index + getProgress(position, panelPos, nextPosition);\n    }\n  }\n\n  // Options Getter\n  /**\n   * A value indicating where the {@link Camera#alignPosition alignPosition} should be located at inside the viewport element\n   * @ko {@link Camera#alignPosition alignPosition}이 뷰포트 엘리먼트 내의 어디에 위치해야 하는지를 나타내는 값\n   * @type {ALIGN | string | number}\n   */\n  public get align() { return this._align; }\n\n  // Options Setter\n  public set align(val: FlickingOptions[\"align\"]) {\n    this._align = val;\n  }\n\n  /** */\n  public constructor({\n    align = ALIGN.CENTER\n  }: Partial<CameraOptions> = {}) {\n    this._flicking = null;\n    this._resetInternalValues();\n\n    // Options\n    this._align = align;\n  }\n\n  /**\n   * Initialize Camera\n   * @ko Camera를 초기화합니다\n   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking의 인스턴스</ko>\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE VAL_MUST_NOT_NULL} If the camera element(`.flicking-camera`) does not exist inside viewport element\n   * <ko>{@link ERROR_CODE VAL_MUST_NOT_NULL} 뷰포트 엘리먼트 내부에 카메라 엘리먼트(`.flicking-camera`)가 존재하지 않을 경우</ko>\n   * @return {this}\n   */\n  public init(flicking: Flicking): this {\n    this._flicking = flicking;\n\n    const viewportEl = flicking.viewport.element;\n\n    checkExistence(viewportEl.firstElementChild, \"First element child of the viewport element\");\n    this._el = viewportEl.firstElementChild as HTMLElement;\n    this._checkTranslateSupport();\n\n    this._updateMode();\n\n    return this;\n  }\n\n  /**\n   * Destroy Camera and return to initial state\n   * @ko Camera를 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy(): this {\n    this._flicking = null;\n    this._resetInternalValues();\n    return this;\n  }\n\n  /**\n   * Move to the given position and apply CSS transform\n   * @ko 해당 좌표로 이동하고, CSS transform을 적용합니다\n   * @param {number} pos A new position<ko>움직일 위치</ko>\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public lookAt(pos: number): void {\n    const flicking = getFlickingAttached(this._flicking);\n    const prevPos = this._position;\n\n    this._position = pos;\n    const toggled = this._togglePanels(prevPos, pos);\n    this._refreshVisiblePanels();\n    this._checkNeedPanel();\n    this._checkReachEnd(prevPos, pos);\n    this.applyTransform();\n\n    if (toggled) {\n      void flicking.renderer.render().then(() => {\n        this.updateOffset();\n      });\n    }\n  }\n\n  /**\n   * Return a previous {@link AnchorPoint} of given {@link AnchorPoint}\n   * If it does not exist, return `null` instead\n   * @ko 주어진 {@link AnchorPoint}의 이전 {@link AnchorPoint}를 반환합니다\n   * 존재하지 않을 경우 `null`을 반환합니다\n   * @param {AnchorPoint} anchor A reference {@link AnchorPoint}<ko>기준 {@link AnchorPoint}</ko>\n   * @return {AnchorPoint | null} The previous {@link AnchorPoint}<ko>이전 {@link AnchorPoint}</ko>\n   */\n  public getPrevAnchor(anchor: AnchorPoint): AnchorPoint | null {\n    if (!this._circularEnabled || anchor.index !== 0) {\n      return this._anchors[anchor.index - 1] || null;\n    } else {\n      const anchors = this._anchors;\n      const rangeDiff = this.rangeDiff;\n      const lastAnchor = anchors[anchors.length - 1];\n\n      return new AnchorPoint({\n        index: lastAnchor.index,\n        position: lastAnchor.position - rangeDiff,\n        panel: lastAnchor.panel\n      });\n    }\n  }\n\n  /**\n   * Return a next {@link AnchorPoint} of given {@link AnchorPoint}\n   * If it does not exist, return `null` instead\n   * @ko 주어진 {@link AnchorPoint}의 다음 {@link AnchorPoint}를 반환합니다\n   * 존재하지 않을 경우 `null`을 반환합니다\n   * @param {AnchorPoint} anchor A reference {@link AnchorPoint}<ko>기준 {@link AnchorPoint}</ko>\n   * @return {AnchorPoint | null} The next {@link AnchorPoint}<ko>다음 {@link AnchorPoint}</ko>\n   */\n  public getNextAnchor(anchor: AnchorPoint): AnchorPoint | null {\n    const anchors = this._anchors;\n\n    if (!this._circularEnabled || anchor.index !== anchors.length - 1) {\n      return anchors[anchor.index + 1] || null;\n    } else {\n      const rangeDiff = this.rangeDiff;\n      const firstAnchor = anchors[0];\n\n      return new AnchorPoint({\n        index: firstAnchor.index,\n        position: firstAnchor.position + rangeDiff,\n        panel: firstAnchor.panel\n      });\n    }\n  }\n\n  /**\n   * Return the camera's position progress in the panel below\n   * Value is from 0 to 1 when the camera's inside panel\n   * Value can be lower than 0 or bigger than 1 when it's in the margin area\n   * @ko 현재 카메라 아래 패널에서의 위치 진행도를 반환합니다\n   * 반환값은 카메라가 패널 내부에 있을 경우 0부터 1까지의 값을 갖습니다\n   * 패널의 margin 영역에 있을 경우 0보다 작거나 1보다 큰 값을 반환할 수 있습니다\n   */\n  public getProgressInPanel(panel: Panel) {\n    const panelRange = panel.range;\n\n    return (this._position - panelRange.min) / (panelRange.max - panelRange.min);\n  }\n\n  /**\n   * Return {@link AnchorPoint} that includes given position\n   * If there's no {@link AnchorPoint} that includes the given position, return `null` instead\n   * @ko 주어진 좌표를 포함하는 {@link AnchorPoint}를 반환합니다\n   * 주어진 좌표를 포함하는 {@link AnchorPoint}가 없을 경우 `null`을 반환합니다\n   * @param {number} position A position to check<ko>확인할 좌표</ko>\n   * @return {AnchorPoint | null} The {@link AnchorPoint} that includes the given position<ko>해당 좌표를 포함하는 {@link AnchorPoint}</ko>\n   */\n  public findAnchorIncludePosition(position: number): AnchorPoint | null {\n    return this._mode.findAnchorIncludePosition(position);\n  }\n\n  /**\n   * Return {@link AnchorPoint} nearest to given position\n   * If there're no {@link AnchorPoint}s, return `null` instead\n   * @ko 해당 좌표에서 가장 가까운 {@link AnchorPoint}를 반환합니다\n   * {@link AnchorPoint}가 하나도 없을 경우 `null`을 반환합니다\n   * @param {number} position A position to check<ko>확인할 좌표</ko>\n   * @return {AnchorPoint | null} The {@link AnchorPoint} nearest to the given position<ko>해당 좌표에 가장 인접한 {@link AnchorPoint}</ko>\n   */\n  public findNearestAnchor(position: number): AnchorPoint | null {\n    const anchors = this._anchors;\n\n    if (anchors.length <= 0) return null;\n\n    let prevDist = Infinity;\n    for (let anchorIdx = 0; anchorIdx < anchors.length; anchorIdx++) {\n      const anchor = anchors[anchorIdx];\n      const dist = Math.abs(anchor.position - position);\n\n      if (dist > prevDist) {\n        // Return previous anchor\n        return anchors[anchorIdx - 1];\n      }\n\n      prevDist = dist;\n    }\n\n    // Return last anchor\n    return anchors[anchors.length - 1];\n  }\n\n  /**\n   * Return {@link AnchorPoint} that matches {@link Flicking#currentPanel}\n   * @ko 현재 {@link Flicking#currentPanel}에 해당하는 {@link AnchorPoint}를 반환합니다\n   * @return {AnchorPoint | null}\n   */\n  public findActiveAnchor(): AnchorPoint | null {\n    const flicking = getFlickingAttached(this._flicking);\n    const activeIndex = flicking.control.activeIndex;\n\n    return find(this._anchors, anchor => anchor.panel.index === activeIndex);\n  }\n\n  /**\n   * Clamp the given position between camera's range\n   * @ko 주어진 좌표를 Camera가 도달 가능한 범위 사이의 값으로 만듭니다\n   * @param {number} position A position to clamp<ko>범위를 제한할 좌표</ko>\n   * @return {number} A clamped position<ko>범위 제한된 좌표</ko>\n   */\n  public clampToReachablePosition(position: number): number {\n    return this._mode.clampToReachablePosition(position);\n  }\n\n  /**\n   * Check whether the given panel is inside of the Camera's range\n   * @ko 해당 {@link Panel}이 Camera가 도달 가능한 범위 내에 있는지를 반환합니다\n   * @param panel An instance of {@link Panel} to check<ko>확인할 {@link Panel}의 인스턴스</ko>\n   * @return {boolean} Whether the panel's inside Camera's range<ko>도달 가능한 범위 내에 해당 패널이 존재하는지 여부</ko>\n   */\n  public canReach(panel: Panel): boolean {\n    return this._mode.canReach(panel);\n  }\n\n  /**\n   * Check whether the given panel element is visible at the current position\n   * @ko 현재 좌표에서 해당 패널 엘리먼트를 볼 수 있는지 여부를 반환합니다\n   * @param panel An instance of {@link Panel} to check<ko>확인할 {@link Panel}의 인스턴스</ko>\n   * @return Whether the panel element is visible at the current position<ko>현재 위치에서 해당 패널 엘리먼트가 보이는지 여부</ko>\n   */\n  public canSee(panel: Panel): boolean {\n    return this._mode.canSee(panel);\n  }\n\n  /**\n   * Update {@link Camera#range range} of Camera\n   * @ko Camera의 {@link Camera#range range}를 업데이트합니다\n   * @method\n   * @abstract\n   * @memberof Camera\n   * @instance\n   * @name updateRange\n   * @chainable\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @return {this}\n   */\n  public updateRange() {\n    const flicking = getFlickingAttached(this._flicking);\n    const renderer = flicking.renderer;\n    const panels = renderer.panels;\n\n    this._updateMode();\n    this._range = this._mode.getRange();\n\n    if (this._circularEnabled) {\n      panels.forEach(panel => panel.updateCircularToggleDirection());\n    }\n\n    this.updateOffset();\n\n    return this;\n  }\n\n  /**\n   * Update Camera's {@link Camera#alignPosition alignPosition}\n   * @ko Camera의 {@link Camera#alignPosition alignPosition}을 업데이트합니다\n   * @chainable\n   * @return {this}\n   */\n  public updateAlignPos(): this {\n    const align = this._align;\n\n    const alignVal = typeof align === \"object\"\n      ? (align as { camera: string | number }).camera\n      : align;\n\n    this._alignPos = parseAlign(alignVal, this.size);\n\n    return this;\n  }\n\n  /**\n   * Update Camera's {@link Camera#anchorPoints anchorPoints}\n   * @ko Camera의 {@link Camera#anchorPoints anchorPoints}를 업데이트합니다\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @chainable\n   * @return {this}\n   */\n  public updateAnchors(): this {\n    this._anchors = this._mode.getAnchors();\n\n    return this;\n  }\n\n  /**\n   * Update Viewport's height to active panel's height\n   * @ko 현재 선택된 패널의 높이와 동일하도록 뷰포트의 높이를 업데이트합니다\n   * @throws {FlickingError}\n   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before\n   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>\n   * @chainable\n   * @return {this}\n   */\n  public updateAdaptiveHeight() {\n    const flicking = getFlickingAttached(this._flicking);\n    const activePanel = flicking.control.activePanel;\n\n    if (!flicking.horizontal || !flicking.adaptive || !activePanel) return;\n\n    flicking.viewport.setSize({\n      height: activePanel.height\n    });\n  }\n\n  /**\n   * Update current offset of the camera\n   * @ko 현재 카메라의 오프셋을 업데이트합니다\n   * @chainable\n   * @return {this}\n   */\n  public updateOffset(): this {\n    const flicking = getFlickingAttached(this._flicking);\n    const position = this._position;\n    const unRenderedPanels = flicking.panels.filter(panel => !panel.rendered);\n\n    this._offset = unRenderedPanels\n      .filter(panel => panel.position + panel.offset < position)\n      .reduce((offset, panel) => offset + panel.sizeIncludingMargin, 0);\n\n    this._circularOffset = this._mode.getCircularOffset();\n\n    this.applyTransform();\n\n    return this;\n  }\n\n  /**\n   * Reset the history of {@link Flicking#event:needPanel needPanel} events so it can be triggered again\n   * @ko 발생한 {@link Flicking#event:needPanel needPanel} 이벤트들을 초기화하여 다시 발생할 수 있도록 합니다\n   * @chainable\n   * @return {this}\n   */\n  public resetNeedPanelHistory(): this {\n    this._needPanelTriggered = { prev: false, next: false };\n    return this;\n  }\n\n  /**\n   * Apply \"transform\" style with the current position to camera element\n   * @ko 현재 위치를 기준으로한 transform 스타일을 카메라 엘리먼트에 적용합니다.\n   * @chainable\n   * @return {this}\n   */\n  public applyTransform(): this {\n    const el = this._el;\n    const flicking = getFlickingAttached(this._flicking);\n\n    const actualPosition = this._position - this._alignPos - this._offset + this._circularOffset;\n\n    el.style[this._transform] = flicking.horizontal\n      ? `translate(${-actualPosition}px)`\n      : `translate(0, ${-actualPosition}px)`;\n\n    return this;\n  }\n\n  private _resetInternalValues() {\n    this._position = 0;\n    this._alignPos = 0;\n    this._offset = 0;\n    this._circularOffset = 0;\n    this._circularEnabled = false;\n    this._range = { min: 0, max: 0 };\n    this._visiblePanels = [];\n    this._anchors = [];\n    this._needPanelTriggered = { prev: false, next: false };\n  }\n\n  private _refreshVisiblePanels() {\n    const flicking = getFlickingAttached(this._flicking);\n    const panels = flicking.renderer.panels;\n\n    const newVisiblePanels = panels.filter(panel => this.canSee(panel));\n    const prevVisiblePanels = this._visiblePanels;\n    this._visiblePanels = newVisiblePanels;\n\n    const added: Panel[] = newVisiblePanels.filter(panel => !includes(prevVisiblePanels, panel));\n    const removed: Panel[] = prevVisiblePanels.filter(panel => !includes(newVisiblePanels, panel));\n\n    if (added.length > 0 || removed.length > 0) {\n      void flicking.renderer.render().then(() => {\n        flicking.trigger(new ComponentEvent(EVENTS.VISIBLE_CHANGE, {\n          added,\n          removed,\n          visiblePanels: newVisiblePanels\n        }));\n      });\n    }\n  }\n\n  private _checkNeedPanel(): void {\n    const needPanelTriggered = this._needPanelTriggered;\n\n    if (needPanelTriggered.prev && needPanelTriggered.next) return;\n\n    const flicking = getFlickingAttached(this._flicking);\n    const panels = flicking.renderer.panels;\n\n    if (panels.length <= 0) {\n      if (!needPanelTriggered.prev) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, { direction: DIRECTION.PREV }));\n        needPanelTriggered.prev = true;\n      }\n      if (!needPanelTriggered.next) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, { direction: DIRECTION.NEXT }));\n        needPanelTriggered.next = true;\n      }\n\n      return;\n    }\n\n    const cameraPosition = this._position;\n    const cameraSize = this.size;\n    const cameraRange = this._range;\n    const needPanelThreshold = flicking.needPanelThreshold;\n\n    const cameraPrev = cameraPosition - this._alignPos;\n    const cameraNext = cameraPrev + cameraSize;\n\n    const firstPanel = panels[0];\n    const lastPanel = panels[panels.length - 1];\n\n    if (!needPanelTriggered.prev) {\n      const firstPanelPrev = firstPanel.range.min;\n\n      if (cameraPrev <= (firstPanelPrev + needPanelThreshold) || cameraPosition <= (cameraRange.min + needPanelThreshold)) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, { direction: DIRECTION.PREV }));\n        needPanelTriggered.prev = true;\n      }\n    }\n\n    if (!needPanelTriggered.next) {\n      const lastPanelNext = lastPanel.range.max;\n\n      if (cameraNext >= (lastPanelNext - needPanelThreshold) || cameraPosition >= (cameraRange.max - needPanelThreshold)) {\n        flicking.trigger(new ComponentEvent(EVENTS.NEED_PANEL, { direction: DIRECTION.NEXT }));\n        needPanelTriggered.next = true;\n      }\n    }\n  }\n\n  private _checkReachEnd(prevPos: number, newPos: number): void {\n    const flicking = getFlickingAttached(this._flicking);\n    const range = this._range;\n\n    const wasBetweenRange = prevPos > range.min && prevPos < range.max;\n    const isBetweenRange = newPos > range.min && newPos < range.max;\n\n    if (!wasBetweenRange || isBetweenRange) return;\n\n    const direction = newPos <= range.min ? DIRECTION.PREV : DIRECTION.NEXT;\n\n    flicking.trigger(new ComponentEvent(EVENTS.REACH_EDGE, {\n      direction\n    }));\n  }\n\n  private _checkTranslateSupport = () => {\n    const transforms = [\"webkitTransform\", \"msTransform\", \"MozTransform\", \"OTransform\", \"transform\"];\n\n    const supportedStyle = document.documentElement.style;\n    let transformName = \"\";\n    for (const prefixedTransform of transforms) {\n      if (prefixedTransform in supportedStyle) {\n        transformName = prefixedTransform;\n      }\n    }\n\n    if (!transformName) {\n      throw new FlickingError(ERROR.MESSAGE.TRANSFORM_NOT_SUPPORTED, ERROR.CODE.TRANSFORM_NOT_SUPPORTED);\n    }\n\n    this._transform = transformName;\n  };\n\n  private _updateMode() {\n    const flicking = getFlickingAttached(this._flicking);\n\n    if (flicking.circular) {\n      const circularMode = new CircularCameraMode(flicking);\n      const canSetCircularMode = circularMode.checkAvailability();\n\n      if (canSetCircularMode) {\n        this._mode = circularMode;\n      } else {\n        const fallbackMode = flicking.circularFallback;\n\n        this._mode = fallbackMode === CIRCULAR_FALLBACK.BOUND\n          ? new BoundCameraMode(flicking)\n          : new LinearCameraMode(flicking);\n      }\n\n      this._circularEnabled = canSetCircularMode;\n    } else {\n      this._mode = flicking.bound\n        ? new BoundCameraMode(flicking)\n        : new LinearCameraMode(flicking);\n    }\n  }\n\n  private _togglePanels(prevPos: number, pos: number): boolean {\n    if (pos === prevPos) return false;\n\n    const flicking = getFlickingAttached(this._flicking);\n    const panels = flicking.renderer.panels;\n    const toggled = panels.map(panel => panel.toggle(prevPos, pos));\n\n    return toggled.some(isToggled => isToggled);\n  }\n}\n\nexport default Camera;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { ComponentEvent } from \"@egjs/component\";\nimport ImReady from \"@egjs/imready\";\n\nimport Flicking, { FlickingOptions } from \"../Flicking\";\nimport Panel, { PanelOptions } from \"../core/panel/Panel\";\nimport FlickingError from \"../core/FlickingError\";\nimport { ALIGN, EVENTS } from \"../const/external\";\nimport * as ERROR from \"../const/error\";\nimport { getFlickingAttached, getMinusCompensatedIndex, includes, parsePanelAlign } from \"../utils\";\n\nimport RenderingStrategy from \"./strategy/RenderingStrategy\";\n\nexport interface RendererOptions {\n  align?: FlickingOptions[\"align\"];\n  strategy: RenderingStrategy;\n}\n\n/**\n * A component that manages {@link Panel} and its elements\n * @ko {@link Panel}과 그 엘리먼트들을 관리하는 컴포넌트\n */\nabstract class Renderer {\n  // Internal States\n  protected _flicking: Flicking | null;\n  protected _panels: Panel[];\n\n  // Options\n  protected _align: NonNullable<RendererOptions[\"align\"]>;\n  protected _strategy: RendererOptions[\"strategy\"];\n\n  // Internal states Getter\n  /**\n   * Array of panels\n   * @ko 전체 패널들의 배열\n   * @type {Panel[]}\n   * @readonly\n   * @see Panel\n   */\n  public get panels() { return this._panels; }\n  /**\n   * Count of panels\n   * @ko 전체 패널의 개수\n   * @type {number}\n   * @readonly\n   */\n  public get panelCount() { return this._panels.length; }\n  /**\n   * @internal\n   */\n  public get strategy() { return this._strategy; }\n\n  // Options Getter\n  /**\n   * A {@link Panel}'s {@link Panel#align align} value that applied to all panels\n   * @ko {@link Panel}에 공통적으로 적용할 {@link Panel#align align} 값\n   * @type {Constants.ALIGN | string | number}\n   */\n  public get align() { return this._align; }\n\n  // Options Setter\n  public set align(val: NonNullable<RendererOptions[\"align\"]>) {\n    this._align = val;\n\n    const panelAlign = parsePanelAlign(val);\n    this._panels.forEach(panel => { panel.align = panelAlign; });\n  }\n\n  /**\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {Constants.ALIGN | string | number} [options.align=\"center\"] An {@link Flicking#align align} value that will be applied to all panels<ko>전체 패널에 적용될 {@link Flicking#align align} 값</ko>\n   * @param {object} [options.strategy] An instance of RenderingStrategy(internal module)<ko>RenderingStrategy의 인스턴스(내부 모듈)</ko>\n   */\n  public constructor({\n    align = ALIGN.CENTER,\n    strategy\n  }: RendererOptions) {\n    this._flicking = null;\n    this._panels = [];\n\n    // Bind options\n    this._align = align;\n    this._strategy = strategy;\n  }\n\n  /**\n   * Render panel elements inside the camera element\n   * @ko 패널 엘리먼트들을 카메라 엘리먼트 내부에 렌더링합니다\n   * @method\n   * @abstract\n   * @memberof Renderer\n   * @instance\n   * @name render\n   * @chainable\n   * @return {this}\n   */\n  public abstract render(): Promise<void>;\n\n  protected abstract _collectPanels(): void;\n  protected abstract _createPanel(el: any, options: Omit<PanelOptions, \"elementProvider\">): Panel;\n\n  /**\n   * Initialize Renderer\n   * @ko Renderer를 초기화합니다\n   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking의 인스턴스</ko>\n   * @chainable\n   * @return {this}\n   */\n  public init(flicking: Flicking): this {\n    this._flicking = flicking;\n    this._collectPanels();\n\n    return this;\n  }\n\n  /**\n   * Destroy Renderer and return to initial state\n   * @ko Renderer를 초기 상태로 되돌립니다\n   * @return {void}\n   */\n  public destroy(): void {\n    this._flicking = null;\n    this._panels = [];\n  }\n\n  /**\n   * Return the {@link Panel} at the given index. `null` if it doesn't exists.\n   * @ko 주어진 인덱스에 해당하는 {@link Panel}을 반환합니다. 주어진 인덱스에 해당하는 패널이 존재하지 않을 경우 `null`을 반환합니다.\n   * @return {Panel | null} Panel at the given index<ko>주어진 인덱스에 해당하는 패널</ko>\n   * @see Panel\n   */\n  public getPanel(index: number): Panel | null {\n    return this._panels[index] || null;\n  }\n\n  public forceRenderAllPanels(): Promise<void> {\n    this._panels.forEach(panel => panel.markForShow());\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Update all panel sizes\n   * @ko 모든 패널의 크기를 업데이트합니다\n   * @chainable\n   * @return {this}\n   */\n  public updatePanelSize(): this {\n    const flicking = getFlickingAttached(this._flicking);\n    const panels = this._panels;\n\n    if (panels.length <= 0) return this;\n\n    if (flicking.panelsPerView > 0) {\n      const firstPanel = panels[0];\n      firstPanel.resize();\n\n      this._updatePanelSizeByGrid(firstPanel, panels);\n    } else {\n      flicking.panels.forEach(panel => panel.resize());\n    }\n\n    return this;\n  }\n\n  /**\n   * Insert new panels at given index\n   * This will increase index of panels after by the number of panels added\n   * @ko 주어진 인덱스에 새로운 패널들을 추가합니다\n   * 해당 인덱스보다 같거나 큰 인덱스를 가진 기존 패널들은 추가한 패널의 개수만큼 인덱스가 증가합니다.\n   * @param {Array<object>} items An array of items to insert<ko>추가할 아이템들의 배열</ko>\n   * @param {number} [items.index] Index to insert new panels at<ko>새로 패널들을 추가할 인덱스</ko>\n   * @param {any[]} [items.elements] An array of element or framework component with element in it<ko>엘리먼트의 배열 혹은 프레임워크에서 엘리먼트를 포함한 컴포넌트들의 배열</ko>\n   * @param {boolean} [items.hasDOMInElements] Whether it contains actual DOM elements. If set to true, renderer will add them to the camera element<ko>내부에 실제 DOM 엘리먼트들을 포함하고 있는지 여부. true로 설정할 경우, 렌더러는 해당 엘리먼트들을 카메라 엘리먼트 내부에 추가합니다</ko>\n   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>\n   */\n  public batchInsert(...items: Array<{\n    index: number;\n    elements: any[];\n    hasDOMInElements: boolean;\n  }>): Panel[] {\n    const panels = this._panels;\n    const flicking = getFlickingAttached(this._flicking);\n\n    const { control } = flicking;\n    const prevFirstPanel = panels[0];\n    const align = parsePanelAlign(this._align);\n\n    const allPanelsInserted = items.reduce((addedPanels, item) => {\n      const insertingIdx = getMinusCompensatedIndex(item.index, panels.length);\n      const panelsPushed = panels.slice(insertingIdx);\n      const panelsInserted = item.elements.map((el, idx) => this._createPanel(el, { index: insertingIdx + idx, align, flicking }));\n\n      panels.splice(insertingIdx, 0, ...panelsInserted);\n\n      if (item.hasDOMInElements) {\n        // Insert the actual elements as camera element's children\n        this._insertPanelElements(panelsInserted, panelsPushed[0] ?? null);\n      }\n\n      // Resize the newly added panels\n      if (flicking.panelsPerView > 0) {\n        const firstPanel = prevFirstPanel || panelsInserted[0].resize();\n\n        this._updatePanelSizeByGrid(firstPanel, panelsInserted);\n      } else {\n        panelsInserted.forEach(panel => panel.resize());\n      }\n\n      // Update panel indexes & positions\n      panelsPushed.forEach(panel => {\n        panel.increaseIndex(panelsInserted.length);\n        panel.updatePosition();\n      });\n\n      return [...addedPanels, ...panelsInserted];\n    }, []);\n\n    if (allPanelsInserted.length <= 0) return [];\n\n    // Update camera & control\n    this._updateCameraAndControl();\n\n    void this.render();\n\n    // Move to the first panel added if no panels existed\n    // FIXME: fix for animating case\n    if (allPanelsInserted.length > 0 && !control.animating) {\n      void control.moveToPanel(control.activePanel || allPanelsInserted[0], {\n        duration: 0\n      }).catch(() => void 0);\n    }\n\n    flicking.camera.updateOffset();\n\n    flicking.trigger(new ComponentEvent(EVENTS.PANEL_CHANGE, {\n      added: allPanelsInserted,\n      removed: []\n    }));\n\n    this.checkPanelContentsReady(allPanelsInserted);\n\n    return allPanelsInserted;\n  }\n\n  /**\n   * Remove the panel at the given index\n   * This will decrease index of panels after by the number of panels removed\n   * @ko 주어진 인덱스의 패널을 제거합니다\n   * 해당 인덱스보다 큰 인덱스를 가진 기존 패널들은 제거한 패널의 개수만큼 인덱스가 감소합니다\n   * @param {Array<object>} items An array of items to remove<ko>제거할 아이템들의 배열</ko>\n   * @param {number} [items.index] Index of panel to remove<ko>제거할 패널의 인덱스</ko>\n   * @param {number} [items.deleteCount=1] Number of panels to remove from index<ko>`index` 이후로 제거할 패널의 개수</ko>\n   * @param {boolean} [items.hasDOMInElements=1] Whether it contains actual DOM elements. If set to true, renderer will remove them from the camera element<ko>내부에 실제 DOM 엘리먼트들을 포함하고 있는지 여부. true로 설정할 경우, 렌더러는 해당 엘리먼트들을 카메라 엘리먼트 내부에서 제거합니다</ko>\n   * @return An array of removed panels<ko>제거된 패널들의 배열</ko>\n   */\n  public batchRemove(...items: Array<{ index: number; deleteCount: number; hasDOMInElements: boolean }>): Panel[] {\n    const panels = this._panels;\n    const flicking = getFlickingAttached(this._flicking);\n\n    const { camera, control } = flicking;\n    const activePanel = control.activePanel;\n    const activeIndex = control.activeIndex;\n\n    const allPanelsRemoved = items.reduce((removed, item) => {\n      const { index, deleteCount } = item;\n      const removingIdx = getMinusCompensatedIndex(index, panels.length);\n\n      const panelsPulled = panels.slice(removingIdx + deleteCount);\n      const panelsRemoved = panels.splice(removingIdx, deleteCount);\n\n      if (panelsRemoved.length <= 0) return [];\n\n      // Update panel indexes & positions\n      panelsPulled.forEach(panel => {\n        panel.decreaseIndex(panelsRemoved.length);\n        panel.updatePosition();\n      });\n\n      if (item.hasDOMInElements) {\n        this._removePanelElements(panelsRemoved);\n      }\n\n      // Remove panel elements\n      panelsRemoved.forEach(panel => panel.destroy());\n\n      if (includes(panelsRemoved, activePanel)) {\n        control.resetActive();\n      }\n\n      return [...removed, ...panelsRemoved];\n    }, []);\n\n    // Update camera & control\n    this._updateCameraAndControl();\n\n    void this.render();\n\n    // FIXME: fix for animating case\n    if (allPanelsRemoved.length > 0 && !control.animating) {\n      const targetPanel = includes(allPanelsRemoved, activePanel)\n        ? (panels[activeIndex] || panels[panels.length - 1])\n        : activePanel;\n\n      if (targetPanel) {\n        void control.moveToPanel(targetPanel, {\n          duration: 0\n        }).catch(() => void 0);\n      } else {\n        // All panels removed\n        camera.lookAt(0);\n      }\n    }\n\n    flicking.camera.updateOffset();\n\n    flicking.trigger(new ComponentEvent(EVENTS.PANEL_CHANGE, {\n      added: [],\n      removed: allPanelsRemoved\n    }));\n\n    return allPanelsRemoved;\n  }\n\n  /**\n   * @internal\n   */\n  public checkPanelContentsReady(checkingPanels: Panel[]) {\n    const flicking = getFlickingAttached(this._flicking);\n    const resizeOnContentsReady = flicking.resizeOnContentsReady;\n    const panels = this._panels;\n\n    if (!resizeOnContentsReady || flicking.virtualEnabled) return;\n\n    const hasContents = (panel: Panel) => !!panel.element.querySelector(\"img, video\");\n    checkingPanels = checkingPanels.filter(panel => hasContents(panel));\n\n    if (checkingPanels.length <= 0) return;\n\n    const contentsReadyChecker = new ImReady();\n\n    checkingPanels.forEach(panel => {\n      panel.loading = true;\n    });\n\n    contentsReadyChecker.on(\"readyElement\", e => {\n      if (!this._flicking) {\n        // Renderer's destroy() is called before\n        contentsReadyChecker.destroy();\n        return;\n      }\n\n      const panel = checkingPanels[e.index];\n      const camera = flicking.camera;\n      const control = flicking.control;\n      const prevProgressInPanel = control.activePanel\n        ? camera.getProgressInPanel(control.activePanel)\n        : 0;\n\n      panel.loading = false;\n      panel.resize();\n      panels.slice(panel.index + 1).forEach(panelBehind => panelBehind.updatePosition());\n\n      if (!flicking.initialized) return;\n\n      camera.updateRange();\n      camera.updateAnchors();\n\n      if (control.animating) {\n        // TODO: Need Axes update\n      } else {\n        control.updatePosition(prevProgressInPanel);\n        control.updateInput();\n      }\n    });\n\n    contentsReadyChecker.on(\"preReady\", e => {\n      if (this._flicking) {\n        void this.render();\n      }\n\n      if (e.readyCount === e.totalCount) {\n        contentsReadyChecker.destroy();\n      }\n    });\n\n    contentsReadyChecker.on(\"ready\", () => {\n      if (this._flicking) {\n        void this.render();\n      }\n      contentsReadyChecker.destroy();\n    });\n\n    contentsReadyChecker.check(checkingPanels.map(panel => panel.element));\n  }\n\n  protected _updateCameraAndControl() {\n    const flicking = getFlickingAttached(this._flicking);\n    const { camera, control } = flicking;\n\n    camera.updateRange();\n    camera.updateAnchors();\n    camera.resetNeedPanelHistory();\n    control.updateInput();\n  }\n\n  protected _showOnlyVisiblePanels(flicking: Flicking) {\n    const panels = flicking.renderer.panels;\n    const camera = flicking.camera;\n\n    const visibleIndexes = camera.visiblePanels.reduce((visibles, panel) => {\n      visibles[panel.index] = true;\n      return visibles;\n    }, {});\n\n    panels.forEach(panel => {\n      if (panel.index in visibleIndexes || panel.loading) {\n        panel.markForShow();\n      } else if (!flicking.holding) {\n        // During the input sequence,\n        // Do not remove panel elements as it won't trigger touchend event.\n        panel.markForHide();\n      }\n    });\n  }\n\n  protected _updatePanelSizeByGrid(referencePanel: Panel, panels: Panel[]) {\n    const flicking = getFlickingAttached(this._flicking);\n    const panelsPerView = flicking.panelsPerView;\n\n    if (panelsPerView <= 0) {\n      throw new FlickingError(ERROR.MESSAGE.WRONG_OPTION(\"panelsPerView\", panelsPerView), ERROR.CODE.WRONG_OPTION);\n    }\n    if (panels.length <= 0) return;\n\n    const viewportSize = flicking.camera.size;\n    const gap = referencePanel.margin.prev + referencePanel.margin.next;\n\n    const panelSize = (viewportSize - gap * (panelsPerView - 1)) / panelsPerView;\n    const panelSizeObj = flicking.horizontal\n      ? { width: panelSize }\n      : { height: panelSize };\n    const firstPanelSizeObj = {\n      size: panelSize,\n      height: referencePanel.height,\n      margin: referencePanel.margin\n    };\n\n    if (!flicking.noPanelStyleOverride) {\n      this._strategy.updatePanelSizes(flicking, panelSizeObj);\n    }\n\n    flicking.panels.forEach(panel => panel.resize(firstPanelSizeObj));\n  }\n\n  protected _removeAllChildsFromCamera() {\n    const flicking = getFlickingAttached(this._flicking);\n    const cameraElement = flicking.camera.element;\n\n    // Remove other elements\n    while (cameraElement.firstChild) {\n      cameraElement.removeChild(cameraElement.firstChild);\n    }\n  }\n\n  protected _insertPanelElements(panels: Panel[], nextSibling: Panel | null = null) {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n    const cameraElement = camera.element;\n    const nextSiblingElement = nextSibling?.element || null;\n    const fragment = document.createDocumentFragment();\n\n    panels.forEach(panel => fragment.appendChild(panel.element));\n    cameraElement.insertBefore(fragment, nextSiblingElement);\n  }\n\n  protected _removePanelElements(panels: Panel[]) {\n    const flicking = getFlickingAttached(this._flicking);\n    const cameraElement = flicking.camera.element;\n\n    panels.forEach(panel => {\n      cameraElement.removeChild(panel.element);\n    });\n  }\n}\n\nexport default Renderer;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { getFlickingAttached, toArray } from \"../utils\";\nimport Panel, { PanelOptions } from \"../core/panel/Panel\";\n\nimport Renderer from \"./Renderer\";\n\n/**\n *\n */\nclass VanillaRenderer extends Renderer {\n  // eslint-disable-next-line @typescript-eslint/require-await\n  public async render() {\n    const flicking = getFlickingAttached(this._flicking);\n    const strategy = this._strategy;\n\n    strategy.updateRenderingPanels(flicking);\n    strategy.renderPanels(flicking);\n\n    this._resetPanelElementOrder();\n  }\n\n  protected _collectPanels() {\n    const flicking = getFlickingAttached(this._flicking);\n    const camera = flicking.camera;\n\n    this._removeAllTextNodes();\n    this._panels = this._strategy.collectPanels(flicking, camera.children);\n  }\n\n  protected _createPanel(el: HTMLElement, options: Omit<PanelOptions, \"elementProvider\">): Panel {\n    return this._strategy.createPanel(el, options);\n  }\n\n  private _resetPanelElementOrder() {\n    const flicking = getFlickingAttached(this._flicking);\n    const cameraEl = flicking.camera.element;\n\n    // We're using reversed panels here as last panel should be the last element of camera element\n    const reversedElements = this._strategy\n      .getRenderingElementsByOrder(flicking)\n      .reverse();\n\n    reversedElements.forEach((el, idx) => {\n      const nextEl = reversedElements[idx - 1] ? reversedElements[idx - 1] : null;\n\n      if (el.nextElementSibling !== nextEl) {\n        cameraEl.insertBefore(el, nextEl);\n      }\n    });\n  }\n\n  private _removeAllTextNodes() {\n    const flicking = getFlickingAttached(this._flicking);\n    const cameraElement = flicking.camera.element;\n\n    // Remove all text nodes in the camera element\n    toArray(cameraElement.childNodes).forEach(node => {\n      if (node.nodeType === Node.TEXT_NODE) {\n        cameraElement.removeChild(node);\n      }\n    });\n  }\n}\n\nexport default VanillaRenderer;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Panel from \"../core/panel/Panel\";\n\nimport Renderer from \"./Renderer\";\n\n/**\n * @internal\n */\nabstract class ExternalRenderer extends Renderer {\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  protected _removePanelElements(panels: Panel[]): void {\n    // DO NOTHING, overrided to prevent an unexpected error\n  }\n\n  protected _removeAllChildsFromCamera(): void {\n    // DO NOTHING, overrided to prevent an unexpected error\n  }\n  /* eslint-enable @typescript-eslint/no-unused-vars */\n}\n\nexport default ExternalRenderer;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../../Flicking\";\nimport { getProgress, getStyle, parseAlign, setSize } from \"../../utils\";\nimport { ALIGN, DIRECTION } from \"../../const/external\";\nimport { LiteralUnion, ValueOf } from \"../../type/internal\";\n\nimport ElementProvider from \"./provider/ElementProvider\";\n\nexport interface PanelOptions {\n  index: number;\n  align: LiteralUnion<ValueOf<typeof ALIGN>> | number;\n  flicking: Flicking;\n  elementProvider: ElementProvider;\n}\n\n/**\n * A slide data component that holds information of a single HTMLElement\n * @ko 슬라이드 데이터 컴포넌트로, 단일 HTMLElement의 정보를 갖고 있습니다\n */\nclass Panel {\n  // Internal States\n  protected _flicking: Flicking;\n  protected _elProvider: ElementProvider;\n  protected _index: number;\n  protected _pos: number;\n  protected _size: number;\n  protected _height: number;\n  protected _margin: { prev: number; next: number };\n  protected _alignPos: number; // Actual align pos\n  protected _rendered: boolean;\n  protected _removed: boolean;\n  protected _loading: boolean;\n  protected _toggleDirection: ValueOf<typeof DIRECTION>;\n  protected _toggled: boolean;\n  protected _togglePosition: number;\n\n  // Options\n  protected _align: PanelOptions[\"align\"];\n\n  // Internal States Getter\n  /**\n   * `HTMLElement` that panel's referencing\n   * @ko 패널이 참조하고 있는 `HTMLElement`\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._elProvider.element; }\n  /**\n   * @internal\n   * @readonly\n   */\n  public get elementProvider() { return this._elProvider; }\n  /**\n   * Index of the panel\n   * @ko 패널의 인덱스\n   * @type {number}\n   * @readonly\n   */\n  public get index() { return this._index; }\n  /**\n   * Position of the panel, including {@link Panel#alignPosition alignPosition}\n   * @ko 패널의 현재 좌표, {@link Panel#alignPosition alignPosition}을 포함하고 있습니다\n   * @type {number}\n   * @readonly\n   */\n  public get position() { return this._pos + this._alignPos; }\n  /**\n   * Cached size of the panel element\n   * This is equal to {@link Panel#element element}'s `offsetWidth` if {@link Flicking#horizontal horizontal} is `true`, and `offsetHeight` else\n   * @ko 패널 엘리먼트의 캐시된 크기\n   * 이 값은 {@link Flicking#horizontal horizontal}이 `true`일 경우 {@link Panel#element element}의 `offsetWidth`와 동일하고, `false`일 경우 `offsetHeight`와 동일합니다\n   * @type {number}\n   * @readonly\n   */\n  public get size() { return this._size; }\n  /**\n   * Panel's size including CSS `margin`\n   * This value includes {@link Panel#element element}'s margin left/right if {@link Flicking#horizontal horizontal} is `true`, and margin top/bottom else\n   * @ko CSS `margin`을 포함한 패널의 크기\n   * 이 값은 {@link Flicking#horizontal horizontal}이 `true`일 경우 margin left/right을 포함하고, `false`일 경우 margin top/bottom을 포함합니다\n   * @type {number}\n   * @readonly\n   */\n  public get sizeIncludingMargin() { return this._size + this._margin.prev + this._margin.next; }\n  /**\n   * Height of the panel element\n   * @ko 패널 엘리먼트의 높이\n   * @type {number}\n   * @readonly\n   */\n  public get height() { return this._height; }\n  /**\n   * Cached CSS `margin` value of the panel element\n   * @ko 패널 엘리먼트의 CSS `margin` 값\n   * @type {object}\n   * @property {number} prev CSS `margin-left` when the {@link Flicking#horizontal horizontal} is `true`, and `margin-top` else\n   * <ko>{@link Flicking#horizontal horizontal}이 `true`일 경우 `margin-left`, `false`일 경우 `margin-top`에 해당하는 값</ko>\n   * @property {number} next CSS `margin-right` when the {@link Flicking#horizontal horizontal} is `true`, and `margin-bottom` else\n   * <ko>{@link Flicking#horizontal horizontal}이 `true`일 경우 `margin-right`, `false`일 경우 `margin-bottom`에 해당하는 값</ko>\n   * @readonly\n   */\n  public get margin() { return this._margin; }\n  /**\n   * Align position inside the panel where {@link Camera}'s {@link Camera#alignPosition alignPosition} inside viewport should be located at\n   * @ko 패널의 정렬 기준 위치. {@link Camera}의 뷰포트 내에서의 {@link Camera#alignPosition alignPosition}이 위치해야 하는 곳입니다\n   * @type {number}\n   * @readonly\n   */\n  public get alignPosition() { return this._alignPos; }\n  /**\n   * A value indicating whether the panel's {@link Flicking#remove remove}d\n   * @ko 패널이 {@link Flicking#remove remove}되었는지 여부를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public get removed() { return this._removed; }\n  /**\n   * A value indicating whether the panel's element is being rendered on the screen\n   * @ko 패널의 엘리먼트가 화면상에 렌더링되고있는지 여부를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public get rendered() { return this._rendered; }\n  /**\n   * A value indicating whether the panel's image/video is not loaded and waiting for resize\n   * @ko 패널 내부의 이미지/비디오가 아직 로드되지 않아 {@link Panel#resize resize}될 것인지를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public get loading() { return this._loading; }\n  /**\n   * Panel element's range of the bounding box\n   * @ko 패널 엘리먼트의 Bounding box 범위\n   * @type {object}\n   * @property {number} [min] Bounding box's left({@link Flicking#horizontal horizontal}: true) / top({@link Flicking#horizontal horizontal}: false)\n   * @property {number} [max] Bounding box's right({@link Flicking#horizontal horizontal}: true) / bottom({@link Flicking#horizontal horizontal}: false)\n   * @readonly\n   */\n  public get range() { return { min: this._pos, max: this._pos + this._size }; }\n  /**\n   * A value indicating whether the panel's position is toggled by circular behavior\n   * @ko 패널의 위치가 circular 동작에 의해 토글되었는지 여부를 나타내는 값\n   * @type {boolean}\n   * @readonly\n   */\n  public get toggled() { return this._toggled; }\n  /**\n   * A direction where the panel's position is toggled\n   * @ko 패널의 위치가 circular 동작에 의해 토글되는 방향\n   * @type {DIRECTION}\n   * @readonly\n   */\n  public get toggleDirection() { return this._toggleDirection; }\n  /**\n   * Actual position offset determined by {@link Panel#order}\n   * @ko {@link Panel#order}에 의한 실제 위치 변경값\n   * @type {number}\n   * @readonly\n   */\n  public get offset() {\n    const toggleDirection = this._toggleDirection;\n    const cameraRangeDiff = this._flicking.camera.rangeDiff;\n\n    return toggleDirection === DIRECTION.NONE || !this._toggled\n      ? 0\n      : toggleDirection === DIRECTION.PREV\n        ? -cameraRangeDiff\n        : cameraRangeDiff;\n  }\n\n  /**\n   * Progress of movement between previous or next panel relative to current panel\n   * @ko 이 패널로부터 이전/다음 패널으로의 이동 진행률\n   * @type {number}\n   * @readonly\n   */\n  public get progress() {\n    const flicking = this._flicking;\n\n    return this.index - flicking.camera.progress;\n  }\n\n  /**\n   * Progress of movement between points that panel is completely invisible outside of viewport(prev direction: -1, selected point: 0, next direction: 1)\n   * @ko 현재 패널이 뷰포트 영역 밖으로 완전히 사라지는 지점을 기준으로 하는 진행도(prev방향: -1, 선택 지점: 0, next방향: 1)\n   * @type {number}\n   * @readonly\n   */\n  public get outsetProgress() {\n    const position = this.position + this.offset;\n    const alignPosition = this._alignPos;\n    const camera = this._flicking.camera;\n    const camPos = camera.position;\n\n    if (camPos === position) {\n      return 0;\n    }\n\n    if (camPos < position) {\n      const disappearPosNext = position + (camera.size - camera.alignPosition) + alignPosition;\n\n      return -getProgress(camPos, position, disappearPosNext);\n    } else {\n      const disappearPosPrev = position - (camera.alignPosition + this._size - alignPosition);\n\n      return 1 - getProgress(camPos, disappearPosPrev, position);\n    }\n  }\n\n  /**\n   * Percentage of area where panel is visible in the viewport\n   * @ko 뷰포트 안에서 패널이 보이는 영역의 비율\n   * @type {number}\n   * @readonly\n   */\n  public get visibleRatio() {\n    const range = this.range;\n    const size = this._size;\n    const offset = this.offset;\n    const visibleRange = this._flicking.camera.visibleRange;\n\n    const checkingRange = {\n      min: range.min + offset,\n      max: range.max + offset\n    };\n\n    if (checkingRange.max <= visibleRange.min || checkingRange.min >= visibleRange.max) {\n      return 0;\n    }\n\n    let visibleSize = size;\n\n    if (visibleRange.min > checkingRange.min) {\n      visibleSize -= visibleRange.min - checkingRange.min;\n    }\n    if (visibleRange.max < checkingRange.max) {\n      visibleSize -= checkingRange.max - visibleRange.max;\n    }\n\n    return visibleSize / size;\n  }\n\n  public set loading(val: boolean) { this._loading = val; }\n\n  // Options Getter\n  /**\n   * A value indicating where the {@link Panel#alignPosition alignPosition} should be located at inside the panel element\n   * @ko {@link Panel#alignPosition alignPosition}이 패널 내의 어디에 위치해야 하는지를 나타내는 값\n   * @type {Constants.ALIGN | string | number}\n   */\n  public get align() { return this._align; }\n\n  // Options Setter\n  public set align(val: PanelOptions[\"align\"]) { this._align = val; }\n\n  /**\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {number} [options.index] An initial index of the panel<ko>패널의 초기 인덱스</ko>\n   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>패널의 초기 {@link Flicking#align align}값</ko>\n   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>패널이 참조하는 {@link Flicking} 인스턴스</ko>\n   * @param {Flicking} [options.elementProvider] A provider instance that redirects elements<ko>실제 엘리먼트를 반환하는 엘리먼트 공급자의 인스턴스</ko>\n   */\n  public constructor({\n    index,\n    align,\n    flicking,\n    elementProvider\n  }: PanelOptions) {\n    this._index = index;\n    this._flicking = flicking;\n    this._elProvider = elementProvider;\n\n    this._align = align;\n\n    this._removed = false;\n    this._rendered = true;\n    this._loading = false;\n    this._resetInternalStates();\n  }\n\n  /**\n   * Mark panel element to be appended on the camera element\n   * @internal\n   */\n  public markForShow() {\n    this._rendered = true;\n    this._elProvider.show(this._flicking);\n  }\n\n  /**\n   * Mark panel element to be removed from the camera element\n   * @internal\n   */\n  public markForHide() {\n    this._rendered = false;\n    this._elProvider.hide(this._flicking);\n  }\n\n  /**\n   * Update size of the panel\n   * @ko 패널의 크기를 갱신합니다\n   * @param {object} cached Predefined cached size of the panel<ko>사전에 캐시된 패널의 크기 정보</ko>\n   * @chainable\n   * @return {this}\n   */\n  public resize(cached?: {\n    size: number;\n    height: number;\n    margin: { prev: number; next: number };\n  }): this {\n    const el = this.element;\n    const flicking = this._flicking;\n    const horizontal = flicking.horizontal;\n\n    if (cached) {\n      this._size = cached.size;\n      this._margin = { ...cached.margin };\n      this._height = cached.height;\n    } else {\n      const elStyle = getStyle(el);\n\n      this._size = horizontal ? el.offsetWidth : el.offsetHeight;\n      this._margin = horizontal\n        ? {\n          prev: parseFloat(elStyle.marginLeft || \"0\"),\n          next: parseFloat(elStyle.marginRight || \"0\")\n        } : {\n          prev: parseFloat(elStyle.marginTop || \"0\"),\n          next: parseFloat(elStyle.marginBottom || \"0\")\n        };\n      this._height = horizontal ? el.offsetHeight : this._size;\n    }\n\n    this.updatePosition();\n    this._updateAlignPos();\n\n    return this;\n  }\n\n  /**\n   * Change panel's size. This will change the actual size of the panel element by changing its CSS width/height property\n   * @ko 패널 크기를 변경합니다. 패널 엘리먼트에 해당 크기의 CSS width/height를 적용합니다\n   * @param {object} [size] New panel size<ko>새 패널 크기</ko>\n   * @param {number|string} [size.width] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>\n   * @param {number|string} [size.height] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>\n   * @chainable\n   * @return {this}\n   */\n  public setSize(size: Partial<{\n    width: number | string;\n    height: number | string;\n  }>): this {\n    setSize(this.element, size);\n\n    return this;\n  }\n\n  /**\n   * Check whether the given element is inside of this panel's {@link Panel#element element}\n   * @ko 해당 엘리먼트가 이 패널의 {@link Panel#element element} 내에 포함되어 있는지를 반환합니다\n   * @param {HTMLElement} element The HTMLElement to check<ko>확인하고자 하는 HTMLElement</ko>\n   * @return {boolean} A Boolean value indicating the element is inside of this panel {@link Panel#element element}<ko>패널의 {@link Panel#element element}내에 해당 엘리먼트 포함 여부</ko>\n   */\n  public contains(element: HTMLElement): boolean {\n    return !!this.element?.contains(element);\n  }\n\n  /**\n   * Reset internal state and set {@link Panel#removed removed} to `true`\n   * @ko 내부 상태를 초기화하고 {@link Panel#removed removed}를 `true`로 설정합니다.\n   * @return {void}\n   */\n  public destroy(): void {\n    this._resetInternalStates();\n    this._removed = true;\n  }\n\n  /**\n   * Check whether the given position is inside of this panel's {@link Panel#range range}\n   * @ko 주어진 좌표가 현재 패널의 {@link Panel#range range}내에 속해있는지를 반환합니다.\n   * @param {number} pos A position to check<ko>확인하고자 하는 좌표</ko>\n   * @param {boolean} [includeMargin=false] Include {@link Panel#margin margin} to the range<ko>패널 영역에 {@link Panel#margin margin}값을 포함시킵니다</ko>\n   * @return {boolean} A Boolean value indicating whether the given position is included in the panel range<ko>해당 좌표가 패널 영역 내에 속해있는지 여부</ko>\n   */\n  public includePosition(pos: number, includeMargin: boolean = false): boolean {\n    return this.includeRange(pos, pos, includeMargin);\n  }\n\n  /**\n   * Check whether the given range is fully included in this panel's area (inclusive)\n   * @ko 주어진 범위가 이 패널 내부에 완전히 포함되는지를 반환합니다\n   * @param {number} min Minimum value of the range to check<ko>확인하고자 하는 최소 범위</ko>\n   * @param {number} max Maximum value of the range to check<ko>확인하고자 하는 최대 범위</ko>\n   * @param {boolean} [includeMargin=false] Include {@link Panel#margin margin} to the range<ko>패널 영역에 {@link Panel#margin margin}값을 포함시킵니다</ko>\n   * @returns {boolean} A Boolean value indicating whether the given range is fully included in the panel range<ko>해당 범위가 패널 영역 내에 완전히 속해있는지 여부</ko>\n   */\n  public includeRange(min: number, max: number, includeMargin: boolean = false): boolean {\n    const margin = this._margin;\n    const panelRange = this.range;\n\n    if (includeMargin) {\n      panelRange.min -= margin.prev;\n      panelRange.max += margin.next;\n    }\n\n    return max >= panelRange.min && min <= panelRange.max;\n  }\n\n  /**\n   * Check whether the panel is visble in the given range (exclusive)\n   * @ko 주어진 범위 내에서 이 패널의 일부가 보여지는지를 반환합니다\n   * @param {number} min Minimum value of the range to check<ko>확인하고자 하는 최소 범위</ko>\n   * @param {number} max Maximum value of the range to check<ko>확인하고자 하는 최대 범위</ko>\n   * @returns {boolean} A Boolean value indicating whether the panel is visible<ko>해당 범위 내에서 패널을 볼 수 있는지 여부</ko>\n   */\n  public isVisibleOnRange(min: number, max: number): boolean {\n    const panelRange = this.range;\n\n    return max > panelRange.min && min < panelRange.max;\n  }\n\n  /**\n   * Move {@link Camera} to this panel\n   * @ko {@link Camera}를 이 패널로 이동합니다\n   * @param {number} [duration] Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>\n   * @returns {Promise<void>} A Promise which will be resolved after reaching the panel<ko>패널 도달시에 resolve되는 Promise</ko>\n   */\n  public focus(duration?: number) {\n    return this._flicking.moveTo(this._index, duration);\n  }\n\n  /**\n   * Get previous(`index - 1`) panel. When the previous panel does not exist, this will return `null` instead\n   * If the {@link Flicking#circularEnabled circular} is enabled, this will return the last panel if called from the first panel\n   * @ko 이전(`index - 1`) 패널을 반환합니다. 이전 패널이 없을 경우 `null`을 반환합니다\n   * {@link Flicking#circularEnabled circular} 모드가 활성화되었을 때 첫번째 패널에서 이 메소드를 호출할 경우 마지막 패널을 반환합니다\n   * @returns {Panel | null} The previous panel<ko>이전 패널</ko>\n   */\n  public prev(): Panel | null {\n    const index = this._index;\n    const flicking = this._flicking;\n    const renderer = flicking.renderer;\n    const panelCount = renderer.panelCount;\n\n    if (panelCount === 1) return null;\n\n    return flicking.circularEnabled\n      ? renderer.getPanel(index === 0 ? panelCount - 1 : index - 1)\n      : renderer.getPanel(index - 1);\n  }\n\n  /**\n   * Get next(`index + 1`) panel. When the next panel does not exist, this will return `null` instead\n   * If the {@link Flicking#circularEnabled circular} is enabled, this will return the first panel if called from the last panel\n   * @ko 다음(`index + 1`) 패널을 반환합니다. 다음 패널이 없을 경우 `null`을 반환합니다\n   * {@link Flicking#circularEnabled circular} 모드가 활성화되었을 때 마지막 패널에서 이 메소드를 호출할 경우 첫번째 패널을 반환합니다\n   * @returns {Panel | null} The previous panel<ko>다음 패널</ko>\n   */\n  public next(): Panel | null {\n    const index = this._index;\n    const flicking = this._flicking;\n    const renderer = flicking.renderer;\n    const panelCount = renderer.panelCount;\n\n    if (panelCount === 1) return null;\n\n    return flicking.circularEnabled\n      ? renderer.getPanel(index === panelCount - 1 ? 0 : index + 1)\n      : renderer.getPanel(index + 1);\n  }\n\n  /**\n   * Increase panel's index by the given value\n   * @ko 패널의 인덱스를 주어진 값만큼 증가시킵니다\n   * @internal\n   * @chainable\n   * @param val An integer greater than or equal to 0<ko>0보다 같거나 큰 정수</ko>\n   * @returns {this}\n   */\n  public increaseIndex(val: number): this {\n    this._index += Math.max(val, 0);\n    return this;\n  }\n\n  /**\n   * Decrease panel's index by the given value\n   * @ko 패널의 인덱스를 주어진 값만큼 감소시킵니다\n   * @internal\n   * @chainable\n   * @param val An integer greater than or equal to 0<ko>0보다 같거나 큰 정수</ko>\n   * @returns {this}\n   */\n  public decreaseIndex(val: number): this {\n    this._index -= Math.max(val, 0);\n    return this;\n  }\n\n  /**\n   * @internal\n   */\n  public updatePosition(): this {\n    const prevPanel = this._flicking.renderer.panels[this._index - 1];\n\n    this._pos = prevPanel\n      ? prevPanel.range.max + prevPanel.margin.next + this._margin.prev\n      : this._margin.prev;\n\n    return this;\n  }\n\n  /**\n   * @internal\n   * @return {boolean} toggled\n   */\n  public toggle(prevPos: number, newPos: number): boolean {\n    const toggleDirection = this._toggleDirection;\n    const togglePosition = this._togglePosition;\n\n    if (toggleDirection === DIRECTION.NONE || newPos === prevPos) return false;\n\n    const prevToggled = this._toggled;\n\n    if (newPos > prevPos) {\n      if (togglePosition >= prevPos && togglePosition <= newPos) {\n        this._toggled = toggleDirection === DIRECTION.NEXT;\n      }\n    } else {\n      if (togglePosition <= prevPos && togglePosition >= newPos) {\n        this._toggled = toggleDirection !== DIRECTION.NEXT;\n      }\n    }\n\n    return prevToggled !== this._toggled;\n  }\n\n  /**\n   * @internal\n   */\n  public updateCircularToggleDirection(): this {\n    const flicking = this._flicking;\n\n    if (!flicking.circularEnabled) {\n      this._toggleDirection = DIRECTION.NONE;\n      this._toggled = false;\n      return this;\n    }\n\n    const camera = flicking.camera;\n    const camRange = camera.range;\n    const camAlignPosition = camera.alignPosition;\n    const camVisibleRange = camera.visibleRange;\n    const camVisibleSize = camVisibleRange.max - camVisibleRange.min;\n\n    const minimumVisible = camRange.min - camAlignPosition;\n    const maximumVisible = camRange.max - camAlignPosition + camVisibleSize;\n\n    const shouldBeVisibleAtMin = this.includeRange(maximumVisible - camVisibleSize, maximumVisible, false);\n    const shouldBeVisibleAtMax = this.includeRange(minimumVisible, minimumVisible + camVisibleSize, false);\n\n    this._toggled = false;\n    if (shouldBeVisibleAtMin) {\n      this._toggleDirection = DIRECTION.PREV;\n      this._togglePosition = this.range.max + camRange.min - camRange.max + camAlignPosition;\n      this.toggle(Infinity, camera.position);\n    } else if (shouldBeVisibleAtMax) {\n      this._toggleDirection = DIRECTION.NEXT;\n      this._togglePosition = this.range.min + camRange.max - camVisibleSize + camAlignPosition;\n      this.toggle(-Infinity, camera.position);\n    } else {\n      this._toggleDirection = DIRECTION.NONE;\n      this._togglePosition = 0;\n    }\n\n    return this;\n  }\n\n  private _updateAlignPos() {\n    this._alignPos = parseAlign(this._align, this._size);\n  }\n\n  private _resetInternalStates() {\n    this._size = 0;\n    this._pos = 0;\n    this._margin = { prev: 0, next: 0 };\n    this._height = 0;\n    this._alignPos = 0;\n    this._toggled = false;\n    this._togglePosition = 0;\n    this._toggleDirection = DIRECTION.NONE;\n  }\n}\n\nexport default Panel;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../../Flicking\";\nimport Panel, { PanelOptions } from \"../../core/panel/Panel\";\nimport ElementProvider from \"../../core/panel/provider/ElementProvider\";\nimport { DIRECTION } from \"../../const/external\";\nimport { parsePanelAlign } from \"../../utils\";\n\nimport RenderingStrategy from \"./RenderingStrategy\";\n\nexport interface NormalRenderingStrategyOptions {\n  providerCtor: new (...args: any) => ElementProvider;\n}\n\n\nclass NormalRenderingStrategy implements RenderingStrategy {\n  private _providerCtor: NormalRenderingStrategyOptions[\"providerCtor\"];\n\n  public constructor({ providerCtor }: NormalRenderingStrategyOptions) {\n    this._providerCtor = providerCtor;\n  }\n\n  public renderPanels() {\n    // DO_NOTHING\n  }\n\n  public getRenderingIndexesByOrder(flicking: Flicking) {\n    const renderedPanels = flicking.renderer.panels.filter(panel => panel.rendered);\n    const toggledPrev = renderedPanels.filter(panel => panel.toggled && panel.toggleDirection === DIRECTION.PREV);\n    const toggledNext = renderedPanels.filter(panel => panel.toggled && panel.toggleDirection === DIRECTION.NEXT);\n    const notToggled = renderedPanels.filter(panel => !panel.toggled);\n\n    return [...toggledPrev, ...notToggled, ...toggledNext].map(panel => panel.index);\n  }\n\n  public getRenderingElementsByOrder(flicking: Flicking) {\n    const panels = flicking.panels;\n\n    return this.getRenderingIndexesByOrder(flicking).map(index => panels[index].element);\n  }\n\n  public updateRenderingPanels(flicking: Flicking) {\n    if (flicking.renderOnlyVisible) {\n      this._showOnlyVisiblePanels(flicking);\n    } else {\n      flicking.panels.forEach(panel => panel.markForShow());\n    }\n  }\n\n  public collectPanels(\n    flicking: Flicking,\n    elements: any[]\n  ) {\n    const align = parsePanelAlign(flicking.renderer.align);\n\n    return elements.map((el, index) => new Panel({\n      index,\n      elementProvider: new this._providerCtor(el),\n      align,\n      flicking\n    }));\n  }\n\n  public createPanel(\n    element: any,\n    options: Omit<PanelOptions, \"elementProvider\">\n  ) {\n    return new Panel({\n      ...options,\n      elementProvider: new this._providerCtor(element)\n    });\n  }\n\n  public updatePanelSizes(flicking: Flicking, size: Partial<{\n    width: number | string;\n    height: number | string;\n  }>) {\n    flicking.panels.forEach(panel => panel.setSize(size));\n  }\n\n  private _showOnlyVisiblePanels(flicking: Flicking) {\n    const panels = flicking.renderer.panels;\n    const camera = flicking.camera;\n\n    const visibleIndexes = camera.visiblePanels.reduce((visibles, panel) => {\n      visibles[panel.index] = true;\n      return visibles;\n    }, {});\n\n    panels.forEach(panel => {\n      if (panel.index in visibleIndexes || panel.loading) {\n        panel.markForShow();\n      } else if (!flicking.holding) {\n        // During the input sequence,\n        // Do not remove panel elements as it won't trigger touchend event.\n        panel.markForHide();\n      }\n    });\n\n    camera.updateOffset();\n  }\n}\n\nexport default NormalRenderingStrategy;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { DIRECTION } from \"../../const/external\";\nimport { circulateIndex } from \"../../utils\";\n\nimport Panel, { PanelOptions } from \"./Panel\";\nimport VirtualElementProvider from \"./provider/VirtualElementProvider\";\n\ninterface VirtualPanelOptions extends PanelOptions {\n  elementProvider: VirtualElementProvider;\n}\n\n/**\n * An slide data component that holds information of a single HTMLElement\n * @ko 슬라이드 데이터 컴포넌트로, 단일 HTMLElement의 정보를 갖고 있습니다\n */\nclass VirtualPanel extends Panel {\n  protected _elProvider: VirtualElementProvider;\n  protected _cachedInnerHTML: string | null;\n\n  /**\n   * `HTMLElement` that panel's referencing\n   * @ko 패널이 참조하고 있는 `HTMLElement`\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._elProvider.element; }\n\n  /**\n   * Cached innerHTML by the previous render function\n   * @ko 이전 렌더링에서 캐시된 innerHTML 정보\n   * @type {string|null}\n   * @readonly\n   */\n  public get cachedInnerHTML() { return this._cachedInnerHTML; }\n\n  /**\n   * An number for indexing which element it will be rendered on\n   * @ko 몇 번째 엘리먼트에 렌더링될 것인지를 나타내는 숫자\n   * @type {number}\n   * @readonly\n   */\n  public get elementIndex() {\n    const flicking = this._flicking;\n    const virtualElCount = flicking.panelsPerView + 1;\n    const panelCount = flicking.panelCount;\n    let index = this._index;\n\n    if (this._toggled) {\n      // To prevent element duplication\n      index = this._toggleDirection === DIRECTION.NEXT\n        ? index + panelCount\n        : index - panelCount;\n    }\n\n    return circulateIndex(index, virtualElCount);\n  }\n\n  /**\n   * @param {object} options An options object<ko>옵션 오브젝트</ko>\n   * @param {number} [options.index] An initial index of the panel<ko>패널의 초기 인덱스</ko>\n   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>패널의 초기 {@link Flicking#align align}값</ko>\n   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>패널이 참조하는 {@link Flicking} 인스턴스</ko>\n   */\n  public constructor(options: VirtualPanelOptions) {\n    super(options);\n\n    options.elementProvider.init(this);\n    this._elProvider = options.elementProvider;\n    this._cachedInnerHTML = null;\n  }\n\n  public cacheRenderResult(result: string) {\n    this._cachedInnerHTML = result;\n  }\n\n  public uncacheRenderResult() {\n    this._cachedInnerHTML = null;\n  }\n\n  public render() {\n    const flicking = this._flicking;\n    const { renderPanel, cache } = flicking.virtual;\n\n    const element = this._elProvider.element;\n    const newInnerHTML = this._cachedInnerHTML || renderPanel(this, this._index);\n\n    if (newInnerHTML === element.innerHTML) return;\n\n    element.innerHTML = newInnerHTML;\n\n    if (cache) {\n      this.cacheRenderResult(newInnerHTML);\n    }\n  }\n\n  public increaseIndex(val: number) {\n    this.uncacheRenderResult();\n    return super.increaseIndex(val);\n  }\n\n  public decreaseIndex(val: number) {\n    this.uncacheRenderResult();\n    return super.decreaseIndex(val);\n  }\n}\n\nexport default VirtualPanel;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"../../Flicking\";\nimport { PanelOptions } from \"../../core/panel/Panel\";\nimport VirtualPanel from \"../../core/panel/VirtualPanel\";\nimport VirtualElementProvider from \"../../core/panel/provider/VirtualElementProvider\";\nimport { parsePanelAlign, range, setSize } from \"../../utils\";\n\nimport RenderingStrategy from \"./RenderingStrategy\";\n\nclass VirtualRenderingStrategy implements RenderingStrategy {\n  public renderPanels(flicking: Flicking) {\n    const virtualManager = flicking.virtual;\n    const visiblePanels = flicking.visiblePanels as VirtualPanel[];\n    const invisibleIndexes = range(flicking.panelsPerView + 1);\n\n    visiblePanels.forEach(panel => {\n      const elementIndex = panel.elementIndex;\n\n      panel.render();\n\n      virtualManager.show(elementIndex);\n      invisibleIndexes[elementIndex] = -1;\n    });\n\n    invisibleIndexes\n      .filter(val => val >= 0)\n      .forEach(idx => {\n        virtualManager.hide(idx);\n      });\n  }\n\n  public getRenderingIndexesByOrder(flicking: Flicking) {\n    const virtualManager = flicking.virtual;\n    const visiblePanels = [...flicking.visiblePanels]\n      .filter(panel => panel.rendered)\n      .sort((panel1, panel2) => {\n        return (panel1.position + panel1.offset) - (panel2.position + panel2.offset);\n      }) as VirtualPanel[];\n\n    if (visiblePanels.length <= 0) return virtualManager.elements.map((_, idx) => idx);\n\n    const visibleIndexes = visiblePanels.map(panel => panel.elementIndex);\n    const invisibleIndexes = virtualManager.elements\n      .map((el, idx) => ({ ...el, idx }))\n      .filter(el => !el.visible)\n      .map(el => el.idx);\n\n    return [...visibleIndexes, ...invisibleIndexes];\n  }\n\n  public getRenderingElementsByOrder(flicking: Flicking) {\n    const virtualManager = flicking.virtual;\n    const elements = virtualManager.elements;\n\n    return this.getRenderingIndexesByOrder(flicking).map(index => elements[index].nativeElement);\n  }\n\n  public updateRenderingPanels(flicking: Flicking) {\n    const panels = flicking.renderer.panels;\n    const camera = flicking.camera;\n\n    const visibleIndexes = camera.visiblePanels.reduce((visibles, panel) => {\n      visibles[panel.index] = true;\n      return visibles;\n    }, {});\n\n    panels.forEach(panel => {\n      if (panel.index in visibleIndexes || panel.loading) {\n        panel.markForShow();\n      } else {\n        panel.markForHide();\n      }\n    });\n\n    camera.updateOffset();\n  }\n\n  public collectPanels(flicking: Flicking) {\n    const align = parsePanelAlign(flicking.renderer.align);\n\n    return range(flicking.virtual.initialPanelCount).map(index => new VirtualPanel({\n      index,\n      elementProvider: new VirtualElementProvider(flicking),\n      align,\n      flicking\n    }));\n  }\n\n  public createPanel(_el: any, options: PanelOptions) {\n    return new VirtualPanel({\n      ...options,\n      elementProvider: new VirtualElementProvider(options.flicking)\n    });\n  }\n\n  public updatePanelSizes(flicking: Flicking, size: Partial<{\n    width: number | string;\n    height: number | string;\n  }>) {\n    flicking.virtual.elements.forEach(el => {\n      setSize(el.nativeElement, size);\n    });\n    flicking.panels.forEach(panel => panel.setSize(size));\n  }\n}\n\nexport default VirtualRenderingStrategy;\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Component, { ComponentEvent } from \"@egjs/component\";\n\nimport FlickingError from \"./core/FlickingError\";\nimport Viewport from \"./core/Viewport\";\nimport AutoResizer from \"./core/AutoResizer\";\nimport { Panel } from \"./core/panel\";\nimport { VanillaElementProvider } from \"./core/panel/provider\";\nimport VirtualManager, { VirtualOptions } from \"./core/VirtualManager\";\nimport { Control, SnapControl, SnapControlOptions, FreeControl, StrictControl, FreeControlOptions, StrictControlOptions } from \"./control\";\nimport { Camera } from \"./camera\";\nimport { Renderer, VanillaRenderer, ExternalRenderer, RendererOptions, NormalRenderingStrategy, VirtualRenderingStrategy } from \"./renderer\";\nimport { EVENTS, ALIGN, MOVE_TYPE, DIRECTION, CIRCULAR_FALLBACK } from \"./const/external\";\nimport * as ERROR from \"./const/error\";\nimport { findIndex, getElement, includes, parseElement } from \"./utils\";\nimport { HoldStartEvent, HoldEndEvent, MoveStartEvent, SelectEvent, MoveEvent, MoveEndEvent, WillChangeEvent, WillRestoreEvent, NeedPanelEvent, VisibleChangeEvent, ReachEdgeEvent, ReadyEvent, AfterResizeEvent, BeforeResizeEvent, ChangedEvent, RestoredEvent, PanelChangeEvent } from \"./type/event\";\nimport { LiteralUnion, ValueOf } from \"./type/internal\";\nimport { ElementLike, Plugin, Status, MoveTypeOptions } from \"./type/external\";\n\n/**\n * @interface\n */\nexport interface FlickingEvents {\n  [EVENTS.READY]: ReadyEvent;\n  [EVENTS.BEFORE_RESIZE]: BeforeResizeEvent;\n  [EVENTS.AFTER_RESIZE]: AfterResizeEvent;\n  [EVENTS.HOLD_START]: HoldStartEvent;\n  [EVENTS.HOLD_END]: HoldEndEvent;\n  [EVENTS.MOVE_START]: MoveStartEvent;\n  [EVENTS.MOVE]: MoveEvent;\n  [EVENTS.MOVE_END]: MoveEndEvent;\n  [EVENTS.WILL_CHANGE]: WillChangeEvent;\n  [EVENTS.CHANGED]: ChangedEvent;\n  [EVENTS.WILL_RESTORE]: WillRestoreEvent;\n  [EVENTS.RESTORED]: RestoredEvent;\n  [EVENTS.SELECT]: SelectEvent;\n  [EVENTS.NEED_PANEL]: NeedPanelEvent;\n  [EVENTS.VISIBLE_CHANGE]: VisibleChangeEvent;\n  [EVENTS.REACH_EDGE]: ReachEdgeEvent;\n  [EVENTS.PANEL_CHANGE]: PanelChangeEvent;\n}\n\n/**\n * @interface\n */\nexport interface FlickingOptions {\n  // UI / LAYOUT\n  align: LiteralUnion<ValueOf<typeof ALIGN>> | number | { panel: number | string; camera: number | string };\n  defaultIndex: number;\n  horizontal: boolean;\n  circular: boolean;\n  circularFallback: LiteralUnion<ValueOf<typeof CIRCULAR_FALLBACK>>;\n  bound: boolean;\n  adaptive: boolean;\n  panelsPerView: number;\n  noPanelStyleOverride: boolean;\n  resizeOnContentsReady: boolean;\n  // EVENT\n  needPanelThreshold: number;\n  preventEventsBeforeInit: boolean;\n  // ANIMATION\n  deceleration: number;\n  duration: number;\n  easing: (x: number) => number;\n  // INPUT\n  inputType: string[];\n  moveType: ValueOf<typeof MOVE_TYPE> | MoveTypeOptions<ValueOf<typeof MOVE_TYPE>>;\n  threshold: number;\n  interruptable: boolean;\n  bounce: number | string | [number | string, number | string];\n  iOSEdgeSwipeThreshold: number;\n  preventClickOnDrag: boolean;\n  disableOnInit: boolean;\n  // PERFORMANCE\n  renderOnlyVisible: boolean;\n  virtual: VirtualOptions | null;\n  // OTHERS\n  autoInit: boolean;\n  autoResize: boolean;\n  useResizeObserver: boolean;\n  externalRenderer: ExternalRenderer | null;\n  // @deprecated\n  renderExternal: {\n    renderer: new (options: RendererOptions) => ExternalRenderer;\n    rendererOptions: RendererOptions;\n  } | null;\n}\n\n/**\n * @extends Component\n * @support {\"ie\": \"9+(with polyfill)\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\n * @requires {@link https://github.com/naver/egjs-component|@egjs/component}\n * @requires {@link https://github.com/naver/egjs-axes|@egjs/axes}\n */\nclass Flicking extends Component<FlickingEvents> {\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @type {string}\n   * @readonly\n   * @example\n   * ```ts\n   * Flicking.VERSION;  // ex) 4.0.0\n   * ```\n   */\n  public static VERSION = \"#__VERSION__#\";\n\n  // Core components\n  private _viewport: Viewport;\n  private _autoResizer: AutoResizer;\n  private _camera: Camera;\n  private _control: Control;\n  private _renderer: Renderer;\n  private _virtualManager: VirtualManager;\n\n  // Options\n  private _align: FlickingOptions[\"align\"];\n  private _defaultIndex: FlickingOptions[\"defaultIndex\"];\n  private _horizontal: FlickingOptions[\"horizontal\"];\n  private _circular: FlickingOptions[\"circular\"];\n  private _circularFallback: FlickingOptions[\"circularFallback\"];\n  private _bound: FlickingOptions[\"bound\"];\n  private _adaptive: FlickingOptions[\"adaptive\"];\n  private _panelsPerView: FlickingOptions[\"panelsPerView\"];\n  private _noPanelStyleOverride: FlickingOptions[\"noPanelStyleOverride\"];\n  private _resizeOnContentsReady: FlickingOptions[\"resizeOnContentsReady\"];\n  private _virtual: FlickingOptions[\"virtual\"];\n\n  private _needPanelThreshold: FlickingOptions[\"needPanelThreshold\"];\n  private _preventEventsBeforeInit: FlickingOptions[\"preventEventsBeforeInit\"];\n\n  private _deceleration: FlickingOptions[\"deceleration\"];\n  private _duration: FlickingOptions[\"duration\"];\n  private _easing: FlickingOptions[\"easing\"];\n\n  private _inputType: FlickingOptions[\"inputType\"];\n  private _moveType: FlickingOptions[\"moveType\"];\n  private _threshold: FlickingOptions[\"threshold\"];\n  private _interruptable: FlickingOptions[\"interruptable\"];\n  private _bounce: FlickingOptions[\"bounce\"];\n  private _iOSEdgeSwipeThreshold: FlickingOptions[\"iOSEdgeSwipeThreshold\"];\n  private _preventClickOnDrag: FlickingOptions[\"preventClickOnDrag\"];\n  private _disableOnInit: FlickingOptions[\"disableOnInit\"];\n\n  private _renderOnlyVisible: FlickingOptions[\"renderOnlyVisible\"];\n\n  private _autoInit: FlickingOptions[\"autoInit\"];\n  private _autoResize: FlickingOptions[\"autoResize\"];\n  private _useResizeObserver: FlickingOptions[\"useResizeObserver\"];\n  private _externalRenderer: FlickingOptions[\"externalRenderer\"];\n  private _renderExternal: FlickingOptions[\"renderExternal\"];\n\n  // Internal State\n  private _initialized: boolean;\n  private _plugins: Plugin[];\n\n  // Components\n  /**\n   * {@link Control} instance of the Flicking\n   * @ko 현재 Flicking에 활성화된 {@link Control} 인스턴스\n   * @type {Control}\n   * @default SnapControl\n   * @readonly\n   * @see Control\n   * @see SnapControl\n   * @see FreeControl\n   */\n  public get control() { return this._control; }\n  /**\n   * {@link Camera} instance of the Flicking\n   * @ko 현재 Flicking에 활성화된 {@link Camera} 인스턴스\n   * @type {Camera}\n   * @default LinearCamera\n   * @readonly\n   * @see Camera\n   * @see LinearCamera\n   * @see BoundCamera\n   * @see CircularCamera\n   */\n  public get camera() { return this._camera; }\n  /**\n   * {@link Renderer} instance of the Flicking\n   * @ko 현재 Flicking에 활성화된 {@link Renderer} 인스턴스\n   * @type {Renderer}\n   * @default VanillaRenderer\n   * @readonly\n   * @see Renderer\n   * @see VanillaRenderer\n   * @see ExternalRenderer\n   */\n  public get renderer() { return this._renderer; }\n  /**\n   * A component that manages viewport size\n   * @ko 뷰포트 크기 정보를 담당하는 컴포넌트\n   * @type {Viewport}\n   * @readonly\n   * @see Viewport\n   */\n  public get viewport() { return this._viewport; }\n  // Internal States\n  /**\n   * Whether Flicking's {@link Flicking#init init()} is called.\n   * This is `true` when {@link Flicking#init init()} is called, and is `false` after calling {@link Flicking#destroy destroy()}.\n   * @ko Flicking의 {@link Flicking#init init()}이 호출되었는지를 나타내는 멤버 변수.\n   * 이 값은 {@link Flicking#init init()}이 호출되었으면 `true`로 변하고, {@link Flicking#destroy destroy()}호출 이후에 다시 `false`로 변경됩니다.\n   * @type {boolean}\n   * @default false\n   * @readonly\n   */\n  public get initialized() { return this._initialized; }\n  /**\n   * Whether the `circular` option is enabled.\n   * The {@link Flicking#circular circular} option can't be enabled when sum of the panel sizes are too small.\n   * @ko {@link Flicking#circular circular} 옵션이 활성화되었는지 여부를 나타내는 멤버 변수.\n   * {@link Flicking#circular circular} 옵션은 패널의 크기의 합이 충분하지 않을 경우 비활성화됩니다.\n   * @type {boolean}\n   * @default false\n   * @readonly\n   */\n  public get circularEnabled() { return this._camera.circularEnabled; }\n  /**\n   * Whether the `virtual` option is enabled.\n   * The {@link Flicking#virtual virtual} option can't be enabled when  {@link Flicking#panelsPerView panelsPerView} is less or equal than zero.\n   * @ko {@link Flicking#virtual virtual} 옵션이 활성화되었는지 여부를 나타내는 멤버 변수.\n   * {@link Flicking#virtual virtual} 옵션은 {@link Flicking#panelsPerView panelsPerView} 옵션의 값이 0보다 같거나 작으면 비활성화됩니다.\n   * @type {boolean}\n   * @default false\n   * @readonly\n   */\n  public get virtualEnabled() { return this._panelsPerView > 0 && this._virtual != null; }\n  /**\n   * Index number of the {@link Flicking#currentPanel currentPanel}\n   * @ko {@link Flicking#currentPanel currentPanel}의 인덱스 번호\n   * @type {number}\n   * @default 0\n   * @readonly\n   */\n  public get index() { return this._control.activeIndex; }\n  /**\n   * The root(`.flicking-viewport`) element\n   * @ko root(`.flicking-viewport`) 엘리먼트\n   * @type {HTMLElement}\n   * @readonly\n   */\n  public get element() { return this._viewport.element; }\n  /**\n   * Currently active panel\n   * @ko 현재 선택된 패널\n   * @type {Panel}\n   * @readonly\n   * @see Panel\n   */\n  public get currentPanel() { return this._control.activePanel; }\n  /**\n   * Array of panels\n   * @ko 전체 패널들의 배열\n   * @type {Panel[]}\n   * @readonly\n   * @see Panel\n   */\n  public get panels() { return this._renderer.panels; }\n  /**\n   * Count of panels\n   * @ko 전체 패널의 개수\n   * @type {number}\n   * @readonly\n   */\n  public get panelCount() { return this._renderer.panelCount; }\n  /**\n   * Array of panels that is visible at the current position\n   * @ko 현재 보이는 패널의 배열\n   * @type {Panel[]}\n   * @readonly\n   * @see Panel\n   */\n  public get visiblePanels() { return this._camera.visiblePanels; }\n  /**\n   * Whether Flicking's animating\n   * @ko 현재 애니메이션 동작 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public get animating() { return this._control.animating; }\n  /**\n   * Whether user is clicking or touching\n   * @ko 현재 사용자가 클릭/터치중인지 여부\n   * @type {boolean}\n   * @readonly\n   */\n  public get holding() { return this._control.holding; }\n  /**\n   * A current list of activated plugins\n   * @ko 현재 활성화된 플러그인 목록\n   * @type {Plugin[]}\n   * @readonly\n   */\n  public get activePlugins() { return this._plugins; }\n\n  // Options Getter\n  // UI / LAYOUT\n  /**\n   * Align position of the panels within viewport. You can set different values each for the panel and camera\n   * @ko 뷰포트 내에서 패널 정렬방식을 설정하는 옵션. 카메라와 패널 개별로 옵션을 설정할 수도 있습니다\n   * @type {ALIGN | string | number | { panel: string | number, camera: string | number }}\n   * @property {ALIGN | string | number} panel The align value for each {@link Panel}s<ko>개개의 {@link Panel}에 적용할 값</ko>\n   * @property {ALIGN | string | number} camera The align value for {@link Camera}<ko>{@link Camera}에 적용할 값</ko>\n   * @default \"center\"\n   * @example\n   * ```ts\n   * const possibleOptions = [\n   *   // Literal strings\n   *   \"prev\", \"center\", \"next\",\n   *   // % values, applied to both panel & camera\n   *   \"0%\", \"25%\", \"42%\",\n   *   // px values, arithmetic calculation with (+/-) is also allowed.\n   *   \"0px\", \"100px\", \"50% - 25px\",\n   *   // numbers, same to number + px (\"0px\", \"100px\")\n   *   0, 100, 1000,\n   *   // Setting a different value for panel & camera\n   *   { panel: \"10%\", camera: \"25%\" }\n   * ];\n   *\n   * possibleOptions.forEach(align => {\n   *   new Flicking(\"#el\", { align });\n   * });\n   * ```\n   */\n  public get align() { return this._align; }\n  /**\n   * Index of the panel to move when Flicking's {@link Flicking#init init()} is called. A zero-based integer\n   * @ko Flicking의 {@link Flicking#init init()}이 호출될 때 이동할 디폴트 패널의 인덱스로, 0부터 시작하는 정수입니다\n   * @type {number}\n   * @default 0\n   */\n  public get defaultIndex() { return this._defaultIndex; }\n  /**\n   * Direction of panel movement (true: horizontal, false: vertical)\n   * @ko 패널 이동 방향 (true: 가로방향, false: 세로방향)\n   * @type {boolean}\n   * @default true\n   */\n  public get horizontal() { return this._horizontal; }\n  /**\n   * Enables circular(continuous loop) mode, which connects first/last panel for continuous scrolling.\n   * @ko 순환 모드를 활성화합니다. 순환 모드에서는 양 끝의 패널이 서로 연결되어 끊김없는 스크롤이 가능합니다.\n   * @type {boolean}\n   * @default false\n   */\n  public get circular() { return this._circular; }\n  /**\n   * Set panel control mode for the case when circular cannot be enabled.\n   * \"linear\" will set the view's range from the top of the first panel to the top of the last panel.\n   * \"bound\" will prevent the view from going out of the first/last panel, so it won't show empty spaces before/after the first/last panel.\n   * @ko 순환 모드 사용 불가능시 사용할 패널 조작 범위 설정 방식을 변경합니다.\n   * \"linear\" 사용시 시점이 첫번째 엘리먼트 위에서부터 마지막 엘리먼트 위까지 움직일 수 있도록 설정합니다.\n   * \"bound\" 사용시 시점이 첫번째 엘리먼트와 마지막 엘리먼트의 끝과 끝 사이에서 움직일 수 있도록 설정합니다.\n   * @see CIRCULAR_FALLBACK\n   * @type {string}\n   * @default \"linear\"\n   */\n  public get circularFallback() { return this._circularFallback; }\n  /**\n   * Prevent the view(camera element) from going out of the first/last panel, so it won't show empty spaces before/after the first/last panel\n   * Only can be enabled when `circular=false`\n   * @ko 뷰(카메라 엘리먼트)가 첫번째와 마지막 패널 밖으로 넘어가지 못하게 하여, 첫번째/마지막 패널 전/후의 빈 공간을 보이지 않도록 하는 옵션입니다\n   * `circular=false`인 경우에만 사용할 수 있습니다\n   * @type {boolean}\n   * @default false\n   */\n  public get bound() { return this._bound; }\n  /**\n   * Update height of the viewport element after movement same to the height of the panel below. This can be only enabled when `horizontal=true`\n   * @ko 이동한 후 뷰포트 엘리먼트의 크기를 현재 패널의 높이와 동일하게 설정합니다. `horizontal=true`인 경우에만 사용할 수 있습니다.\n   * @type {boolean}\n   * @default false\n   */\n  public get adaptive() { return this._adaptive; }\n  /**\n   * A visible number of panels on viewport. Enabling this option will automatically resize panel size\n   * @ko 한 화면에 보이는 패널의 개수. 이 옵션을 활성화할 경우 패널의 크기를 강제로 재조정합니다\n   * @type {number}\n   * @default -1\n   */\n  public get panelsPerView() { return this._panelsPerView; }\n  /**\n   * Enabling this option will not change `width/height` style of the panels if {@link Flicking#panelsPerView} is enabled.\n   * This behavior can be useful in terms of performance when you're manually managing all panel sizes\n   * @ko 이 옵션을 활성화할 경우, {@link Flicking#panelsPerView} 옵션이 활성화되었을 때 패널의 `width/height` 스타일을 변경하지 않도록 설정합니다.\n   * 모든 패널들의 크기를 직접 관리하고 있을 경우, 이 옵션을 활성화하면 성능면에서 유리할 수 있습니다\n   * @type {boolean}\n   * @default false\n   */\n  public get noPanelStyleOverride() { return this._noPanelStyleOverride; }\n  /**\n   * Enabling this option will automatically call {@link Flicking#resize} when all image/video inside panels are loaded.\n   * This can be useful when you have contents inside Flicking that changes its size when it's loaded\n   * @ko 이 옵션을 활성화할 경우, Flicking 패널 내부의 이미지/비디오들이 로드되었을 때 자동으로 {@link Flicking#resize}를 호출합니다.\n   * 이 동작은 Flicking 내부에 로드 전/후로 크기가 변하는 콘텐츠를 포함하고 있을 때 유용하게 사용하실 수 있습니다.\n   * @type {boolean}\n   * @default false\n   */\n  public get resizeOnContentsReady() { return this._resizeOnContentsReady; }\n  // EVENTS\n  /**\n   * A Threshold from viewport edge before triggering `needPanel` event\n   * @ko `needPanel`이벤트가 발생하기 위한 뷰포트 끝으로부터의 최대 거리\n   * @type {number}\n   * @default 0\n   */\n  public get needPanelThreshold() { return this._needPanelThreshold; }\n  /**\n   * When enabled, events are not triggered before `ready` when initializing\n   * @ko 활성화할 경우 초기화시 `ready` 이벤트 이전의 이벤트가 발생하지 않습니다.\n   * @type {boolean}\n   * @default true\n   */\n  public get preventEventsBeforeInit() { return this._preventEventsBeforeInit; }\n  // ANIMATION\n  /**\n   * Deceleration value for panel movement animation which is triggered by user input. A higher value means a shorter animation time\n   * @ko 사용자의 동작으로 가속도가 적용된 패널 이동 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아집니다\n   * @type {number}\n   * @default 0.0075\n   */\n  public get deceleration() { return this._deceleration; }\n  /**\n   * An easing function applied to the panel movement animation. Default value is `easeOutCubic`\n   * @ko 패널 이동 애니메이션에 적용할 easing 함수. 기본값은 `easeOutCubic`이다\n   * @type {function}\n   * @default x => 1 - Math.pow(1 - x, 3)\n   * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>이징 함수 Cheat Sheet {@link http://easings.net/}</ko>\n   */\n  public get easing() { return this._easing; }\n  /**\n   * Default duration of the animation (ms)\n   * @ko 디폴트 애니메이션 재생 시간 (ms)\n   * @type {number}\n   * @default 500\n   */\n  public get duration() { return this._duration; }\n  // INPUT\n  /**\n   * Types of input devices to enable\n   * @ko 활성화할 입력 장치 종류\n   * @type {string[]}\n   * @default [\"touch\", \"mouse\"]\n   * @see {@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption Possible values (PanInputOption#inputType)}\n   * <ko>{@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption 가능한 값들 (PanInputOption#inputType)}</ko>\n   */\n  public get inputType() { return this._inputType; }\n  /**\n   * Movement style by user input. This will change instance type of {@link Flicking#control}\n   * You can use the values of the constant {@link MOVE_TYPE}\n   * @ko 사용자 입력에 의한 이동 방식. 이 값에 따라 {@link Flicking#control}의 인스턴스 타입이 결정됩니다\n   * 상수 {@link MOVE_TYPE}에 정의된 값들을 이용할 수 있습니다\n   * @type {MOVE_TYPE | Pair<string, object>}\n   * @default \"snap\"\n   * @example\n   * |moveType|control|options|\n   * |:---:|:---:|:---:|\n   * |\"snap\"|{@link SnapControl}||\n   * |\"freeScroll\"|{@link FreeControl}|{@link FreeControlOptions}|\n   *\n   * ```ts\n   * import Flicking, { MOVE_TYPE } from \"@egjs/flicking\";\n   *\n   * const flicking = new Flicking({\n   *   moveType: MOVE_TYPE.SNAP\n   * });\n   * ```\n   *\n   * ```ts\n   * const flicking = new Flicking({\n   *   // If you want more specific settings for the moveType\n   *   // [moveType, options for that moveType]\n   *   // In this case, it's [\"freeScroll\", FreeControlOptions]\n   *   moveType: [MOVE_TYPE.FREE_SCROLL, { stopAtEdge: true }]\n   * });\n   * ```\n   */\n  public get moveType() { return this._moveType; }\n  /**\n   * Movement threshold to change panel (unit: px). It should be dragged above the threshold to change the current panel.\n   * @ko 패널 변경을 위한 이동 임계값 (단위: px). 주어진 값 이상으로 스크롤해야만 패널 변경이 가능하다.\n   * @type {number}\n   * @default 40\n   */\n  public get threshold() { return this._threshold; }\n  /**\n   * Set animation to be interruptable by click/touch.\n   * @ko 사용자의 클릭/터치로 인해 애니메이션을 도중에 멈출 수 있도록 설정합니다.\n   * @type {boolean}\n   * @default true\n   */\n  public get interruptable() { return this._interruptable; }\n  /**\n   * The size value of the bounce area. Only can be enabled when `circular=false`.\n   * You can set different bounce value for prev/next direction by using array.\n   * `number` for px value, and `string` for px, and % value relative to viewport size.\n   * You have to call {@link Control#updateInput} after changing this to take effect.\n   * @ko Flicking이 최대 영역을 넘어서 갈 수 있는 최대 크기. `circular=false`인 경우에만 사용할 수 있습니다.\n   * 배열을 통해 prev/next 방향에 대해 서로 다른 바운스 값을 지정할 수 있습니다.\n   * `number`를 통해 px값을, `stirng`을 통해 px 혹은 뷰포트 크기 대비 %값을 사용할 수 있습니다.\n   * 이 값을 변경시 {@link Control#updateInput}를 호출해야 합니다.\n   * @type {string | number | Array<string | number>}\n   * @default \"20%\"\n   * @example\n   * ```ts\n   * const possibleOptions = [\n   *   // % values, relative to viewport element(\".flicking-viewport\")'s size\n   *   \"0%\", \"25%\", \"42%\",\n   *   // px values, arithmetic calculation with (+/-) is also allowed.\n   *   \"0px\", \"100px\", \"50% - 25px\",\n   *   // numbers, same to number + px (\"0px\", \"100px\")\n   *   0, 100, 1000\n   * ];\n   * ```\n   *\n   * @example\n   * ```ts\n   * const flicking = new Flicking(\"#el\", { bounce: \"20%\" });\n   *\n   * flicking.bounce = \"100%\";\n   * flicking.control.updateInput(); // Call this to update!\n   * ```\n   */\n  public get bounce() { return this._bounce; }\n  /**\n   * Size of the area from the right edge in iOS safari (in px) which enables swipe-back or swipe-forward\n   * @ko iOS Safari에서 swipe를 통한 뒤로가기/앞으로가기를 활성화하는 오른쪽 끝으로부터의 영역의 크기 (px)\n   * @type {number}\n   * @default 30\n   */\n  public get iOSEdgeSwipeThreshold() { return this._iOSEdgeSwipeThreshold; }\n  /**\n   * Automatically prevent `click` event if the user has dragged at least a single pixel on the viewport element\n   * @ko 사용자가 뷰포트 영역을 1픽셀이라도 드래그했을 경우 자동으로 {@link https://developer.mozilla.org/ko/docs/Web/API/Element/click_event click} 이벤트를 취소합니다\n   * @type {boolean}\n   * @default true\n   */\n  public get preventClickOnDrag() { return this._preventClickOnDrag; }\n  /**\n   * Automatically call {@link Flicking#disableInput disableInput()} on initialization\n   * @ko Flicking init시에 {@link Flicking#disableInput disableInput()}을 바로 호출합니다\n   * @type {boolean}\n   * @default false\n   */\n  public get disableOnInit() { return this._disableOnInit; }\n  // PERFORMANCE\n  /**\n   * Whether to render visible panels only. This can dramatically increase performance when there're many panels\n   * @ko 보이는 패널만 렌더링할지 여부를 설정합니다. 패널이 많을 경우에 퍼포먼스를 크게 향상시킬 수 있습니다\n   * @type {boolean}\n   * @default false\n   */\n  public get renderOnlyVisible() { return this._renderOnlyVisible; }\n  /**\n   * By enabling this option, it will reduce memory consumption by restricting the number of DOM elements to `panelsPerView + 1`\n   * Must be used with `panelsPerview`.\n   * After Flicking's initialized, this property can be used to add/remove the panel count.\n   * @ko 이 옵션을 활성화할 경우 패널 엘리먼트의 개수를 `panelsPerView + 1` 개로 고정함으로써, 메모리 사용량을 줄일 수 있습니다.\n   * `panelsPerView` 옵션과 함께 사용되어야만 합니다.\n   * Flicking 초기화 이후에, 이 프로퍼티는 렌더링하는 패널의 개수를 추가/제거하기 위해 사용될 수 있습니다.\n   * @type {VirtualManager}\n   * @property {function} renderPanel A rendering function for the panel element's innerHTML<ko>패널 엘리먼트의 innerHTML을 렌더링하는 함수</ko>\n   * @property {number} initialPanelCount Initial panel count to render<ko>최초로 렌더링할 패널의 개수</ko>\n   * @property {boolean} [cache=false] Whether to cache rendered panel's innerHTML<ko>렌더링된 패널의 innerHTML 정보를 캐시할지 여부</ko>\n   * @property {string} [panelClass=\"flicking-panel\"] The class name that will be applied to rendered panel elements<ko>렌더링되는 패널 엘리먼트에 적용될 클래스 이름</ko>\n   * @example\n   * ```ts\n   * import Flicking, { VirtualPanel } from \"@egjs/flicking\";\n   *\n   * const flicking = new Flicking(\"#some_el\", {\n   *   panelsPerView: 3,\n   *   virtual: {\n   *     renderPanel: (panel: VirtualPanel, index: number) => `Panel ${index}`,\n   *     initialPanelCount: 100\n   *   }\n   * });\n   *\n   * // Add 100 virtual panels (at the end)\n   * flicking.virtual.append(100);\n   *\n   * // Remove 100 virtual panels from 0 to 100\n   * flicking.virtual.remove(0, 100);\n   * ```\n   */\n  public get virtual() { return this._virtualManager; }\n\n  // OTHERS\n  /**\n   * Call {@link Flicking#init init()} automatically when creating Flicking's instance\n   * @ko Flicking 인스턴스를 생성할 때 자동으로 {@link Flicking#init init()}를 호출합니다\n   * @type {boolean}\n   * @default true\n   * @readonly\n   */\n  public get autoInit() { return this._autoInit; }\n  /**\n   * Whether to automatically call {@link Flicking#resize resize()} when the viewport element(.flicking-viewport)'s size is changed\n   * @ko 뷰포트 엘리먼트(.flicking-viewport)의 크기 변경시 {@link Flicking#resize resize()} 메소드를 자동으로 호출할지 여부를 설정합니다\n   * @type {boolean}\n   * @default true\n   */\n  public get autoResize() { return this._autoResize; }\n  /**\n   * Whether to listen {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver ResizeObserver}'s event instead of Window's {@link https://developer.mozilla.org/ko/docs/Web/API/Window/resize_event resize} event when using the `autoResize` option\n   * @ko autoResize 옵션 사용시 {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver ResizeObserver}의 이벤트를 Window객체의 {@link https://developer.mozilla.org/ko/docs/Web/API/Window/resize_event resize} 이벤트 대신 수신할지 여부를 설정합니다\n   * @type {boolean}\n   * @default true\n   */\n  public get useResizeObserver() { return this._useResizeObserver; }\n  /**\n   * This is an option for the frameworks(React, Vue, Angular, ...). Don't set it as it's automatically managed by Flicking.\n   * @ko 프레임워크(React, Vue, Angular, ...)에서만 사용하는 옵션으로, 자동으로 설정되므로 따로 사용하실 필요 없습니다!\n   * @default null\n   * @internal\n   * @readonly\n   */\n  public get externalRenderer() { return this._externalRenderer; }\n  /**\n   * This is an option for the frameworks(React, Vue, Angular, ...). Don't set it as it's automatically managed by Flicking.\n   * @ko 프레임워크(React, Vue, Angular, ...)에서만 사용하는 옵션으로, 자동으로 설정되므로 따로 사용하실 필요 없습니다!\n   * @default null\n   * @internal\n   * @readonly\n   * @deprecated\n   */\n  public get renderExternal() { return this._renderExternal; }\n\n  // Options Setter\n  // UI / LAYOUT\n  public set align(val: FlickingOptions[\"align\"]) {\n    this._align = val;\n    this._renderer.align = val;\n    this._camera.align = val;\n  }\n\n  public set defaultIndex(val: FlickingOptions[\"defaultIndex\"]) { this._defaultIndex = val; }\n  public set horizontal(val: FlickingOptions[\"horizontal\"]) { this._horizontal = val; }\n  public set circular(val: FlickingOptions[\"circular\"]) { this._circular = val; }\n  public set bound(val: FlickingOptions[\"bound\"]) { this._bound = val; }\n  public set adaptive(val: FlickingOptions[\"adaptive\"]) { this._adaptive = val; }\n  public set panelsPerView(val: FlickingOptions[\"panelsPerView\"]) { this._panelsPerView = val; }\n  public set noPanelStyleOverride(val: FlickingOptions[\"noPanelStyleOverride\"]) { this._noPanelStyleOverride = val; }\n  public set resizeOnContentsReady(val: FlickingOptions[\"resizeOnContentsReady\"]) { this._resizeOnContentsReady = val; }\n  // EVENTS\n  public set needPanelThreshold(val: FlickingOptions[\"needPanelThreshold\"]) { this._needPanelThreshold = val; }\n  public set preventEventsBeforeInit(val: FlickingOptions[\"preventEventsBeforeInit\"]) { this._preventEventsBeforeInit = val; }\n  // ANIMATION\n  public set deceleration(val: FlickingOptions[\"deceleration\"]) { this._deceleration = val; }\n  public set easing(val: FlickingOptions[\"easing\"]) { this._easing = val; }\n  public set duration(val: FlickingOptions[\"duration\"]) { this._duration = val; }\n  // INPUT\n  public set inputType(val: FlickingOptions[\"inputType\"]) { this._inputType = val; }\n  public set moveType(val: FlickingOptions[\"moveType\"]) { this._moveType = val; }\n  public set threshold(val: FlickingOptions[\"threshold\"]) { this._threshold = val; }\n  public set interruptable(val: FlickingOptions[\"interruptable\"]) { this._interruptable = val; }\n  public set bounce(val: FlickingOptions[\"bounce\"]) { this._bounce = val; }\n  public set iOSEdgeSwipeThreshold(val: FlickingOptions[\"iOSEdgeSwipeThreshold\"]) { this._iOSEdgeSwipeThreshold = val; }\n  public set preventClickOnDrag(val: FlickingOptions[\"preventClickOnDrag\"]) {\n    const prevVal = this._preventClickOnDrag;\n\n    if (val === prevVal) return;\n\n    const controller = this._control.controller;\n\n    if (val) {\n      controller.addPreventClickHandler();\n    } else {\n      controller.removePreventClickHandler();\n    }\n\n    this._preventClickOnDrag = val;\n  }\n\n  public set disableOnInit(val: FlickingOptions[\"disableOnInit\"]) { this._disableOnInit = val; }\n  // PERFORMANCE\n  public set renderOnlyVisible(val: FlickingOptions[\"renderOnlyVisible\"]) { this._renderOnlyVisible = val; }\n  // OTHERS\n  public set autoResize(val: FlickingOptions[\"autoResize\"]) {\n    this._autoResize = val;\n\n    if (val) {\n      this._autoResizer.enable();\n    } else {\n      this._autoResizer.disable();\n    }\n  }\n\n  public set useResizeObserver(val: FlickingOptions[\"useResizeObserver\"]) {\n    this._useResizeObserver = val;\n\n    if (this._autoResize) {\n      this._autoResizer.enable();\n    }\n  }\n\n  /**\n   * @param root A root HTMLElement to initialize Flicking on it. When it's a typeof `string`, it should be a css selector string\n   * <ko>Flicking을 초기화할 HTMLElement로, `string` 타입으로 지정시 css 선택자 문자열을 지정해야 합니다.</ko>\n   * @param {object} [options={}] An options object for Flicking.<ko>Flicking에 적용할 옵션 오브젝트</ko>\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE WRONG_TYPE}|When the root is not either string or HTMLElement|\n   * |{@link ERROR_CODE ELEMENT_NOT_FOUND}|When the element with given CSS selector does not exist|\n   * <ko>\n   *\n   * |code|조건|\n   * |---|---|\n   * |{@link ERROR_CODE WRONG_TYPE}|루트 엘리먼트가 string이나 HTMLElement가 아닐 경우|\n   * |{@link ERROR_CODE ELEMENT_NOT_FOUND}|주어진 CSS selector로 엘리먼트를 찾지 못했을 경우|\n   *\n   * </ko>\n   * @example\n   * ```ts\n   * import Flicking from \"@egjs/flicking\";\n   *\n   * // Creating new instance of Flicking with HTMLElement\n   * const flicking = new Flicking(document.querySelector(\".flicking-viewport\"), { circular: true });\n   *\n   * // Creating new instance of Flicking with CSS selector\n   * const flicking2 = new Flicking(\".flicking-viewport\", { circular: true });\n   * ```\n   */\n  public constructor(root: HTMLElement | string, {\n    align = ALIGN.CENTER,\n    defaultIndex = 0,\n    horizontal = true,\n    circular = false,\n    circularFallback = CIRCULAR_FALLBACK.LINEAR,\n    bound = false,\n    adaptive = false,\n    panelsPerView = -1,\n    noPanelStyleOverride = false,\n    resizeOnContentsReady = false,\n    needPanelThreshold = 0,\n    preventEventsBeforeInit = true,\n    deceleration = 0.0075,\n    duration = 500,\n    easing = x => 1 - Math.pow(1 - x, 3),\n    inputType = [\"mouse\", \"touch\"],\n    moveType = \"snap\",\n    threshold = 40,\n    interruptable = true,\n    bounce = \"20%\",\n    iOSEdgeSwipeThreshold = 30,\n    preventClickOnDrag = true,\n    disableOnInit = false,\n    renderOnlyVisible = false,\n    virtual = null,\n    autoInit = true,\n    autoResize = true,\n    useResizeObserver = true,\n    externalRenderer = null,\n    renderExternal = null\n  }: Partial<FlickingOptions> = {}) {\n    super();\n\n    // Internal states\n    this._initialized = false;\n    this._plugins = [];\n\n    // Bind options\n    this._align = align;\n    this._defaultIndex = defaultIndex;\n    this._horizontal = horizontal;\n    this._circular = circular;\n    this._circularFallback = circularFallback;\n    this._bound = bound;\n    this._adaptive = adaptive;\n    this._panelsPerView = panelsPerView;\n    this._noPanelStyleOverride = noPanelStyleOverride;\n    this._resizeOnContentsReady = resizeOnContentsReady;\n    this._virtual = virtual;\n    this._needPanelThreshold = needPanelThreshold;\n    this._preventEventsBeforeInit = preventEventsBeforeInit;\n    this._deceleration = deceleration;\n    this._duration = duration;\n    this._easing = easing;\n    this._inputType = inputType;\n    this._moveType = moveType;\n    this._threshold = threshold;\n    this._interruptable = interruptable;\n    this._bounce = bounce;\n    this._iOSEdgeSwipeThreshold = iOSEdgeSwipeThreshold;\n    this._preventClickOnDrag = preventClickOnDrag;\n    this._disableOnInit = disableOnInit;\n    this._renderOnlyVisible = renderOnlyVisible;\n    this._autoInit = autoInit;\n    this._autoResize = autoResize;\n    this._useResizeObserver = useResizeObserver;\n    this._externalRenderer = externalRenderer;\n    this._renderExternal = renderExternal;\n\n    // Create core components\n    this._viewport = new Viewport(getElement(root));\n    this._autoResizer = new AutoResizer(this);\n    this._renderer = this._createRenderer();\n    this._camera = this._createCamera();\n    this._control = this._createControl();\n    this._virtualManager = new VirtualManager(this, virtual);\n\n    if (this._autoInit) {\n      void this.init();\n    }\n  }\n\n  /**\n   * Initialize Flicking and move to the default index\n   * This is automatically called on Flicking's constructor when `autoInit` is true(default)\n   * @ko Flicking을 초기화하고, 디폴트 인덱스로 이동합니다\n   * 이 메소드는 `autoInit` 옵션이 true(default)일 경우 Flicking이 생성될 때 자동으로 호출됩니다\n   * @fires Flicking#ready\n   * @return {this}\n   */\n  public async init(): Promise<void> {\n    if (this._initialized) return;\n\n    const camera = this._camera;\n    const renderer = this._renderer;\n    const control = this._control;\n    const virtualManager = this._virtualManager;\n    const originalTrigger = this.trigger;\n    const preventEventsBeforeInit = this._preventEventsBeforeInit;\n\n    camera.init(this);\n    virtualManager.init();\n    renderer.init(this);\n    control.init(this);\n\n    if (preventEventsBeforeInit) {\n      this.trigger = () => this;\n    }\n\n    await this.resize();\n\n    // Look at initial panel\n    await this._moveToInitialPanel();\n\n    if (this._autoResize) {\n      this._autoResizer.enable();\n    }\n    if (this._preventClickOnDrag) {\n      control.controller.addPreventClickHandler();\n    }\n    if (this._disableOnInit) {\n      this.disableInput();\n    }\n    renderer.checkPanelContentsReady(renderer.panels);\n\n    this._plugins.forEach(plugin => plugin.init(this));\n\n    // Done initializing & emit ready event\n    this._initialized = true;\n    if (preventEventsBeforeInit) {\n      this.trigger = originalTrigger;\n    }\n    this.trigger(new ComponentEvent(EVENTS.READY));\n\n    return;\n  }\n\n  /**\n   * Destroy Flicking and remove all event handlers\n   * @ko Flicking과 하위 컴포넌트들을 초기 상태로 되돌리고, 부착된 모든 이벤트 핸들러를 제거합니다\n   * @return {void}\n   */\n  public destroy(): void {\n    this.off();\n\n    this._autoResizer.disable();\n    this._control.destroy();\n    this._camera.destroy();\n    this._renderer.destroy();\n\n    this._plugins.forEach(plugin => plugin.destroy());\n\n    this._initialized = false;\n  }\n\n  /**\n   * Move to the previous panel (current index - 1)\n   * @ko 이전 패널로 이동합니다 (현재 인덱스 - 1)\n   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the panel movement animation (unit: ms)<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @async\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the previous panel does not exist|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|이전 패널이 존재하지 않을 경우|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the previous panel<ko>이전 패널 도달시에 resolve되는 Promise</ko>\n   */\n  public prev(duration: number = this._duration): Promise<void> {\n    return this.moveTo(this._control.activePanel?.prev()?.index ?? -1, duration, DIRECTION.PREV);\n  }\n\n  /**\n   * Move to the next panel (current index + 1)\n   * @ko 다음 패널로 이동합니다 (현재 인덱스 + 1)\n   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>\n   * @async\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the next panel does not exist|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|다음 패널이 존재하지 않을 경우|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the next panel<ko>다음 패널 도달시에 resolve되는 Promise</ko>\n   */\n  public next(duration: number = this._duration) {\n    return this.moveTo(this._control.activePanel?.next()?.index ?? this._renderer.panelCount, duration, DIRECTION.NEXT);\n  }\n\n  /**\n   * Move to the panel with given index\n   * @ko 주어진 인덱스에 해당하는 패널로 이동합니다\n   * @param {number} index The index of the panel to move<ko>이동할 패널의 인덱스</ko>\n   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>\n   * @param {DIRECTION} [direction=DIRECTION.NONE] Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>\n   * @async\n   * @fires Flicking#moveStart\n   * @fires Flicking#move\n   * @fires Flicking#moveEnd\n   * @fires Flicking#willChange\n   * @fires Flicking#changed\n   * @fires Flicking#willRestore\n   * @fires Flicking#restored\n   * @fires Flicking#needPanel\n   * @fires Flicking#visibleChange\n   * @fires Flicking#reachEdge\n   * @throws {FlickingError}\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the root is not either string or HTMLElement|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|\n   * <ko>\n   *\n   * |code|condition|\n   * |---|---|\n   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|해당 인덱스를 가진 패널이 존재하지 않을 경우|\n   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|\n   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|\n   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|\n   *\n   * </ko>\n   * @return {Promise<void>} A Promise which will be resolved after reaching the target panel<ko>해당 패널 도달시에 resolve되는 Promise</ko>\n   */\n  public moveTo(index: number, duration: number = this._duration, direction: ValueOf<typeof DIRECTION> = DIRECTION.NONE) {\n    const renderer = this._renderer;\n    const panelCount = renderer.panelCount;\n\n    const panel = renderer.getPanel(index);\n\n    if (!panel) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.INDEX_OUT_OF_RANGE(index, 0, panelCount - 1), ERROR.CODE.INDEX_OUT_OF_RANGE));\n    }\n\n    if (this._control.animating) {\n      return Promise.reject(new FlickingError(ERROR.MESSAGE.ANIMATION_ALREADY_PLAYING, ERROR.CODE.ANIMATION_ALREADY_PLAYING));\n    }\n\n    return this._control.moveToPanel(panel, {\n      duration,\n      direction\n    });\n  }\n\n  /**\n   * Return the {@link Panel} at the given index. `null` if it doesn't exists.\n   * @ko 주어진 인덱스에 해당하는 {@link Panel}을 반환합니다. 주어진 인덱스에 해당하는 패널이 존재하지 않을 경우 `null`을 반환합니다.\n   * @return {Panel | null} Panel at the given index<ko>주어진 인덱스에 해당하는 패널</ko>\n   * @see Panel\n   * @example\n   * ```ts\n   * const panel = flicking.getPanel(0);\n   * // Which is a shorthand to...\n   * const samePanel = flicking.panels[0];\n   * ```\n   */\n  public getPanel(index: number): Panel | null {\n    return this._renderer.getPanel(index);\n  }\n\n  /**\n   * Enable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 활성화합니다\n   * @return {this}\n   */\n  public enableInput(): this {\n    this._control.enable();\n    return this;\n  }\n\n  /**\n   * Disable input from the user (mouse/touch)\n   * @ko 사용자의 입력(마우스/터치)를 막습니다\n   * @return {this}\n   */\n  public disableInput(): this {\n    this._control.disable();\n    return this;\n  }\n\n  /**\n   * Get current flicking status. You can restore current state by giving returned value to {@link Flicking#setStatus setStatus()}\n   * @ko 현재 상태를 반환합니다. 반환받은 값을 {@link Flicking#setStatus setStatus()} 메소드의 인자로 지정하면 현재 상태를 복원할 수 있습니다\n   * @param {object} options Status retrieving options<ko>Status 반환 옵션</ko>\n   * @param {boolean} [options.index=true] Include current panel index to the returning status. Camera will automatically move to the given index when the {@link Flicking#setStatus setStatus} is called<ko>현재 패널 인덱스를 반환값에 포함시킵니다. {@link Flicking#setStatus setStatus} 호출시 자동으로 해당 인덱스로 카메라를 움직입니다</ko>\n   * @param {boolean} [options.position=true] Include camera position to the returning status. This works only when the {@link Flicking#moveType moveType} is `freeScroll`<ko>카메라의 현재 위치를 반환값에 포함시킵니다. 이 옵션은 {@link Flicking#moveType moveType}이 `freeScroll`일 경우에만 동작합니다</ko>\n   * @param {boolean} [options.includePanelHTML=false] Include panel's `outerHTML` to the returning status<ko>패널의 `outerHTML`을 반환값에 포함시킵니다</ko>\n   * @param {boolean} [options.visiblePanelsOnly=false] Include only {@link Flicking#visiblePanel visiblePanel}'s HTML. This option is available only when the `includePanelHTML` is true\n   * <ko>현재 보이는 패널({@link Flicking#visiblePanel visiblePanel})의 HTML만 반환합니다. `includePanelHTML`이 `true`일 경우에만 동작합니다.</ko>\n   * @return {Status} An object with current status value information<ko>현재 상태값 정보를 가진 객체.</ko>\n   */\n  public getStatus({\n    index = true,\n    position = true,\n    includePanelHTML = false,\n    visiblePanelsOnly = false\n  }: Partial<{\n    index: boolean;\n    position: boolean;\n    includePanelHTML: boolean;\n    visiblePanelsOnly: boolean;\n  }> = {}): Status {\n    const camera = this._camera;\n    const panels = visiblePanelsOnly ? this.visiblePanels : this.panels;\n\n    const status: Status = {\n      panels: panels.map(panel => {\n        const panelInfo: Status[\"panels\"][0] = { index: panel.index };\n\n        if (includePanelHTML) {\n          panelInfo.html = panel.element.outerHTML;\n        }\n\n        return panelInfo;\n      })\n    };\n\n    if (index) {\n      status.index = this.index;\n    }\n    if (position) {\n      const nearestAnchor = camera.findNearestAnchor(camera.position);\n\n      if (nearestAnchor) {\n        status.position = {\n          panel: nearestAnchor.panel.index,\n          progressInPanel: camera.getProgressInPanel(nearestAnchor.panel)\n        };\n      }\n\n    }\n\n    if (visiblePanelsOnly) {\n      const visiblePanels = this.visiblePanels;\n\n      status.visibleOffset = visiblePanels[0]?.index ?? 0;\n    }\n\n    return status;\n  }\n\n  /**\n   * Restore to the state of the given {@link Status}\n   * @ko 주어진 {@link Status}의 상태로 복원합니다\n   * @param {Partial<Status>} status Status value to be restored. You should use the return value of the {@link Flicking#getStatus getStatus()} method<ko>복원할 상태 값. {@link Flicking#getStatus getStatus()} 메서드의 반환값을 지정하면 됩니다</ko>\n   * @return {void}\n   */\n  public setStatus(status: Status): void {\n    if (!this._initialized) {\n      throw new FlickingError(ERROR.MESSAGE.NOT_INITIALIZED, ERROR.CODE.NOT_INITIALIZED);\n    }\n\n    const {\n      index,\n      position,\n      visibleOffset,\n      panels\n    } = status;\n\n    const renderer = this._renderer;\n    const control = this._control;\n\n    // Can't add/remove panels on external rendering\n    if (panels[0]?.html && !this._renderExternal) {\n      renderer.batchRemove({ index: 0, deleteCount: this.panels.length, hasDOMInElements: true });\n      renderer.batchInsert({ index: 0, elements: parseElement(panels.map(panel => panel.html!)), hasDOMInElements: true });\n    }\n\n    if (index) {\n      const panelIndex = visibleOffset\n        ? index - visibleOffset\n        : index;\n\n      void this.moveTo(panelIndex, 0).catch(() => void 0);\n    }\n\n    if (position && this._moveType === MOVE_TYPE.FREE_SCROLL) {\n      const { panel, progressInPanel } = position;\n      const panelIndex = visibleOffset\n        ? panel - visibleOffset\n        : panel;\n      const panelRange = renderer.panels[panelIndex].range;\n      const newCameraPos = panelRange.min + (panelRange.max - panelRange.min) * progressInPanel;\n\n      void control.moveToPosition(newCameraPos, 0).catch(() => void 0);\n    }\n  }\n\n  /**\n   * Add plugins that can have different effects on Flicking\n   * @ko 플리킹에 다양한 효과를 부여할 수 있는 플러그인을 추가합니다\n   * @param {...Plugin} plugins The plugin(s) to add<ko>추가할 플러그인(들)</ko>\n   * @return {this}\n   * @see https://github.com/naver/egjs-flicking-plugins\n   */\n  public addPlugins(...plugins: Plugin[]) {\n    if (this._initialized) {\n      plugins.forEach(item => item.init(this));\n    }\n\n    this._plugins.push(...plugins);\n\n    return this;\n  }\n\n  /**\n   * Remove plugins from Flicking.\n   * @ko 플리킹으로부터 플러그인들을 제거합니다.\n   * @param {...Plugin} plugin The plugin(s) to remove.<ko>제거 플러그인(들).</ko>\n   * @return {this}\n   * @see https://github.com/naver/egjs-flicking-plugins\n   */\n  public removePlugins(...plugins: Plugin[]) {\n    plugins.forEach(item => {\n      const foundIndex = findIndex(this._plugins, val => val === item);\n\n      if (foundIndex >= 0) {\n        item.destroy();\n        this._plugins.splice(foundIndex, 1);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Update viewport/panel sizes\n   * @ko 패널 및 뷰포트의 크기를 갱신합니다\n   * @method\n   * @fires Flicking#beforeResize\n   * @fires Flicking#afterResize\n   * @return {this}\n   */\n  public async resize(): Promise<void> {\n    const viewport = this._viewport;\n    const renderer = this._renderer;\n    const camera = this._camera;\n    const control = this._control;\n\n    const activePanel = control.activePanel;\n    const prevWidth = viewport.width;\n    const prevHeight = viewport.height;\n    const prevProgressInPanel = activePanel\n      ? camera.getProgressInPanel(activePanel)\n      : 0;\n\n    this.trigger(new ComponentEvent(EVENTS.BEFORE_RESIZE, {\n      width: prevWidth,\n      height: prevHeight,\n      element: viewport.element\n    }));\n\n    viewport.resize();\n    await renderer.forceRenderAllPanels(); // Render all panel elements, to update sizes\n    renderer.updatePanelSize();\n    camera.updateAlignPos();\n    camera.updateRange();\n    camera.updateAnchors();\n    await renderer.render();\n\n    if (control.animating) {\n      // TODO:\n    } else {\n      control.updatePosition(prevProgressInPanel);\n      control.updateInput();\n    }\n\n    const newWidth = viewport.width;\n    const newHeight = viewport.height;\n    const sizeChanged = newWidth !== prevWidth || newHeight !== prevHeight;\n\n    this.trigger(new ComponentEvent(EVENTS.AFTER_RESIZE, {\n      width: viewport.width,\n      height: viewport.height,\n      prev: {\n        width: prevWidth,\n        height: prevHeight\n      },\n      sizeChanged,\n      element: viewport.element\n    }));\n  }\n\n  /**\n   * Add new panels after the last panel\n   * @ko 패널 목록의 제일 끝에 새로운 패널들을 추가합니다\n   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both\n   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>\n   * @return {Panel[]} An array of appended panels<ko>추가된 패널들의 배열</ko>\n   * @see Panel\n   * @see ElementLike\n   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)\n   * @example\n   * ```ts\n   * const flicking = new Flicking(\"#flick\");\n   * // These are possible parameters\n   * flicking.append(document.createElement(\"div\"));\n   * flicking.append(\"\\<div\\>Panel\\</div\\>\");\n   * flicking.append([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]);\n   * // Even this is possible\n   * flicking.append(\"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\");\n   * ```\n   */\n  public append(element: ElementLike | ElementLike[]): Panel[] {\n    return this.insert(this._renderer.panelCount, element);\n  }\n\n  /**\n   * Add new panels before the first panel\n   * This will increase index of panels after by the number of panels added\n   * @ko 패널 목록의 제일 앞(index 0)에 새로운 패널들을 추가합니다\n   * 추가한 패널의 개수만큼 기존 패널들의 인덱스가 증가합니다.\n   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both\n   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>\n   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>\n   * @see Panel\n   * @see ElementLike\n   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)\n   * @example\n   * ```ts\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.prepend(document.createElement(\"div\"));\n   * flicking.prepend(\"\\<div\\>Panel\\</div\\>\");\n   * flicking.prepend([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]);\n   * // Even this is possible\n   * flicking.prepend(\"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\");\n   * ```\n   */\n  public prepend(element: ElementLike | ElementLike[]): Panel[] {\n    return this.insert(0, element);\n  }\n\n  /**\n   * Insert new panels at given index\n   * This will increase index of panels after by the number of panels added\n   * @ko 주어진 인덱스에 새로운 패널들을 추가합니다\n   * 해당 인덱스보다 같거나 큰 인덱스를 가진 기존 패널들은 추가한 패널의 개수만큼 인덱스가 증가합니다.\n   * @param {number} index Index to insert new panels at<ko>새로 패널들을 추가할 인덱스</ko>\n   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both\n   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>\n   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>\n   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)\n   * @example\n   * ```ts\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.insert(0, document.createElement(\"div\"));\n   * flicking.insert(2, \"\\<div\\>Panel\\</div\\>\");\n   * flicking.insert(1, [\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]);\n   * // Even this is possible\n   * flicking.insert(3, \"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\");\n   * ```\n   */\n  public insert(index: number, element: ElementLike | ElementLike[]): Panel[] {\n    if (this._renderExternal) {\n      throw new FlickingError(ERROR.MESSAGE.NOT_ALLOWED_IN_FRAMEWORK, ERROR.CODE.NOT_ALLOWED_IN_FRAMEWORK);\n    }\n\n    return this._renderer.batchInsert({ index, elements: parseElement(element), hasDOMInElements: true });\n  }\n\n  /**\n   * Remove the panel at the given index\n   * This will decrease index of panels after by the number of panels removed\n   * @ko 주어진 인덱스의 패널을 제거합니다\n   * 해당 인덱스보다 큰 인덱스를 가진 기존 패널들은 제거한 패널의 개수만큼 인덱스가 감소합니다\n   * @param {number} index Index of panel to remove<ko>제거할 패널의 인덱스</ko>\n   * @param {number} [deleteCount=1] Number of panels to remove from index<ko>`index` 이후로 제거할 패널의 개수</ko>\n   * @return {Panel[]} An array of removed panels<ko>제거된 패널들의 배열</ko>\n   */\n  public remove(index: number, deleteCount: number = 1): Panel[] {\n    if (this._renderExternal) {\n      throw new FlickingError(ERROR.MESSAGE.NOT_ALLOWED_IN_FRAMEWORK, ERROR.CODE.NOT_ALLOWED_IN_FRAMEWORK);\n    }\n\n    return this._renderer.batchRemove({ index, deleteCount, hasDOMInElements: true });\n  }\n\n  private _createControl(): Control {\n    const moveType = this._moveType;\n    const moveTypes = Object.keys(MOVE_TYPE).map(key => MOVE_TYPE[key] as ValueOf<typeof MOVE_TYPE>);\n\n    const moveTypeStr = Array.isArray(moveType)\n      ? moveType[0]\n      : moveType;\n\n    const moveTypeOptions = Array.isArray(moveType)\n      ? moveType[1] ?? {}\n      : {};\n\n    if (!includes(moveTypes, moveTypeStr)) {\n      throw new FlickingError(ERROR.MESSAGE.WRONG_OPTION(\"moveType\", JSON.stringify(moveType)), ERROR.CODE.WRONG_OPTION);\n    }\n\n    switch (moveTypeStr) {\n      case MOVE_TYPE.SNAP:\n        return new SnapControl(moveTypeOptions as SnapControlOptions);\n      case MOVE_TYPE.FREE_SCROLL:\n        return new FreeControl(moveTypeOptions as FreeControlOptions);\n      case MOVE_TYPE.STRICT:\n        return new StrictControl(moveTypeOptions as StrictControlOptions);\n    }\n  }\n\n  private _createCamera(): Camera {\n    if (this._circular && this._bound) {\n      // eslint-disable-next-line no-console\n      console.warn(\"\\\"circular\\\" and \\\"bound\\\" option cannot be used together, ignoring bound.\");\n    }\n\n    return new Camera({\n      align: this._align\n    });\n  }\n\n  private _createRenderer(): Renderer {\n    const externalRenderer = this._externalRenderer;\n    if (this._virtual && this._panelsPerView <= 0) {\n      // eslint-disable-next-line no-console\n      console.warn(\"\\\"virtual\\\" and \\\"panelsPerView\\\" option should be used together, ignoring virtual.\");\n    }\n\n    return externalRenderer\n      ? externalRenderer\n      : this._renderExternal\n        ? this._createExternalRenderer()\n        : this._createVanillaRenderer();\n  }\n\n  private _createExternalRenderer(): ExternalRenderer {\n    const {\n      renderer,\n      rendererOptions\n    } = this._renderExternal!;\n\n    return new (renderer)({ align: this._align, ...rendererOptions });\n  }\n\n  private _createVanillaRenderer(): VanillaRenderer {\n    const virtual = this.virtualEnabled;\n\n    return new VanillaRenderer({\n      align: this._align,\n      strategy: virtual\n        ? new VirtualRenderingStrategy()\n        : new NormalRenderingStrategy({\n          providerCtor: VanillaElementProvider\n        })\n    });\n  }\n\n  private async _moveToInitialPanel(): Promise<void> {\n    const renderer = this._renderer;\n    const control = this._control;\n    const initialPanel = renderer.getPanel(this._defaultIndex) || renderer.getPanel(0);\n\n    if (!initialPanel) return;\n\n    control.setActive(initialPanel, null, false);\n\n    return control.moveToPanel(initialPanel, {\n      duration: 0\n    });\n  }\n}\n\nexport default Flicking;\n","import { DiffResult } from \"@egjs/list-differ\";\n\nimport Flicking from \"../Flicking\";\nimport Renderer from \"../renderer/Renderer\";\n\nexport default (flicking: Flicking, diffResult: DiffResult<any>, rendered: any[]) => {\n  const renderer = flicking.renderer;\n  const panels = renderer.panels;\n  const prevList = [...diffResult.prevList];\n\n  if (diffResult.removed.length > 0) {\n    let endIdx = -1;\n    let prevIdx = -1;\n\n    diffResult.removed.forEach(removedIdx => {\n      if (endIdx < 0) {\n        endIdx = removedIdx;\n      }\n\n      if (prevIdx >= 0 && removedIdx !== prevIdx - 1) {\n        batchRemove(renderer, prevIdx, endIdx + 1);\n\n        endIdx = removedIdx;\n        prevIdx = removedIdx;\n      } else {\n        prevIdx = removedIdx;\n      }\n\n      prevList.splice(removedIdx, 1);\n    });\n\n    batchRemove(renderer, prevIdx, endIdx + 1);\n  }\n\n  diffResult.ordered.forEach(([prevIdx, newIdx]) => {\n    const prevPanel = panels[prevIdx];\n    const indexDiff = newIdx - prevIdx;\n\n    if (indexDiff > 0) {\n      const middlePanels = panels.slice(prevIdx + 1, newIdx + 1);\n\n      prevPanel.increaseIndex(indexDiff);\n      middlePanels.forEach(panel => panel.decreaseIndex(1));\n    } else {\n      const middlePanels = panels.slice(newIdx, prevIdx);\n\n      prevPanel.decreaseIndex(-indexDiff);\n      middlePanels.forEach(panel => panel.increaseIndex(1));\n    }\n    // Update position\n    prevPanel.resize();\n  });\n\n  if (diffResult.ordered.length > 0) {\n    panels.sort((panel1, panel2) => panel1.index - panel2.index);\n  }\n\n  if (diffResult.added.length > 0) {\n    let startIdx = -1;\n    let prevIdx = -1;\n\n    const addedElements = rendered.slice(prevList.length);\n\n    diffResult.added.forEach((addedIdx, idx) => {\n      if (startIdx < 0) {\n        startIdx = idx;\n      }\n\n      if (prevIdx >= 0 && addedIdx !== prevIdx + 1) {\n        batchInsert(renderer, diffResult, addedElements, startIdx, idx + 1);\n\n        startIdx = -1;\n        prevIdx = -1;\n      } else {\n        prevIdx = addedIdx;\n      }\n    });\n\n    if (startIdx >= 0) {\n      batchInsert(renderer, diffResult, addedElements, startIdx);\n    }\n  }\n};\n\nconst batchInsert = (renderer: Renderer, diffResult: DiffResult<any>, addedElements: any[], startIdx: number, endIdx?: number) => {\n  renderer.batchInsert(\n    ...diffResult.added.slice(startIdx, endIdx).map((index, elIdx) => ({ index, elements: [addedElements[elIdx]], hasDOMInElements: false }))\n  );\n};\n\nconst batchRemove = (renderer: Renderer, startIdx: number, endIdx?: number) => {\n  const removed = renderer.panels.slice(startIdx, endIdx);\n\n  renderer.batchRemove({ index: startIdx, deleteCount: removed.length, hasDOMInElements: false });\n};\n\n","import { FlickingOptions } from \"../Flicking\";\nimport { ALIGN } from \"../const/external\";\nimport { parseArithmeticExpression } from \"../utils\";\n\nexport default (align: FlickingOptions[\"align\"] = ALIGN.CENTER, horizontal: boolean = true, firstPanelSize?: string) => {\n  const cameraAlign = getCameraAlign(align);\n  const panelAlign = getPanelAlign(align);\n\n  if (panelAlign == null) return \"\";\n\n  const camPosition = `calc(${cameraAlign} - (${firstPanelSize || \"0px\"} * ${panelAlign.percentage}) - ${panelAlign.absolute}px)`;\n\n  return horizontal\n    ? `translate(${camPosition})`\n    : `translate(0, ${camPosition})`;\n};\n\nconst getCameraAlign = (align: FlickingOptions[\"align\"]) => {\n  const alignVal = typeof align === \"object\"\n    ? (align as { camera: string | number }).camera\n    : align;\n\n  return parseAlign(alignVal);\n};\n\nconst getPanelAlign = (align: FlickingOptions[\"align\"]) => {\n  const alignVal = typeof align === \"object\"\n    ? (align as { panel: string | number }).panel\n    : align;\n\n  return parseArithmeticExpression(parseAlign(alignVal));\n};\n\nconst parseAlign = (alignVal: number | string) => {\n  if (typeof alignVal === \"number\") {\n    return `${alignVal}px`;\n  }\n\n  switch (alignVal) {\n    case ALIGN.CENTER:\n      return \"50%\";\n    case ALIGN.NEXT:\n      return \"100%\";\n    case ALIGN.PREV:\n      return \"0%\";\n    default:\n      return alignVal;\n  }\n};\n","import Component from \"@egjs/component\";\n\nimport Flicking from \"../Flicking\";\n\n/**\n * Decorator that makes the method of flicking available in the framework.\n * @ko 프레임워크에서 플리킹의 메소드를 사용할 수 있게 하는 데코레이터.\n * @memberof eg.Flicking\n * @private\n * @example\n * ```js\n * import Flicking, { withFlickingMethods } from \"@egjs/flicking\";\n *\n * class Flicking extends React.Component<Partial<FlickingProps & FlickingOptions>> {\n *   &#64;withFlickingMethods\n *   private flicking: Flicking;\n * }\n * ```\n */\nconst withFlickingMethods = (prototype: any, flickingName: string) => {\n  [Component.prototype, Flicking.prototype].forEach(proto => {\n    Object.getOwnPropertyNames(proto).filter(name => !prototype[name] && !name.startsWith(\"_\") && name !== \"constructor\")\n      .forEach((name: string) => {\n        const descriptor = Object.getOwnPropertyDescriptor(proto, name)!;\n\n        if (descriptor.value) {\n          // Public Function\n          Object.defineProperty(prototype, name, {\n            value: function(...args) {\n              return descriptor.value.call(this[flickingName], ...args);\n            }\n          });\n        } else {\n          const getterDescriptor: { get?: () => any; set?: (val: any) => void } = {};\n          if (descriptor.get) {\n            getterDescriptor.get = function() {\n              return descriptor.get?.call(this[flickingName]);\n            };\n          }\n          if (descriptor.set) {\n            getterDescriptor.set = function(...args) {\n              return descriptor.set?.call(this[flickingName], ...args);\n            };\n          }\n\n          Object.defineProperty(prototype, name, getterDescriptor);\n        }\n      });\n  });\n};\n\nexport default withFlickingMethods;\n","import { DiffResult } from \"@egjs/list-differ\";\n\nimport Flicking from \"../Flicking\";\n\nexport default <T>(flicking: Flicking, diffResult: DiffResult<T>) => {\n  const removedPanels = diffResult.removed.reduce((map, idx) => {\n    map[idx] = true;\n    return map;\n  }, {});\n\n  const maintainedMap = diffResult.maintained.reduce((map, [prev, current]) => {\n    map[prev] = current;\n    return map;\n  }, {});\n\n  return [\n    ...flicking.panels\n      .filter(panel => !removedPanels[panel.index])\n      // Sort panels by position\n      .sort((panel1, panel2) => (panel1.position + panel1.offset) - (panel2.position + panel2.offset))\n      .map(panel => diffResult.list[maintainedMap[panel.index]]),\n    ...diffResult.added.map(idx => diffResult.list[idx])\n  ];\n};\n\n","/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Flicking from \"./Flicking\";\nimport * as Core from \"./core\";\nimport * as Camera from \"./camera\";\nimport * as Control from \"./control\";\nimport * as Renderer from \"./renderer\";\nimport * as Constants from \"./const/external\";\nimport * as CFC from \"./cfc\";\nimport * as Utils from \"./utils\";\nimport { merge } from \"./utils\";\n\nmerge(Flicking, Core);\nmerge(Flicking, Camera);\nmerge(Flicking, Control);\nmerge(Flicking, Renderer);\nmerge(Flicking, Constants);\nmerge(Flicking, CFC);\nmerge(Flicking, Utils);\n\nexport default Flicking;\n"],"names":["STATE_TYPE","CODE","WRONG_TYPE","ELEMENT_NOT_FOUND","VAL_MUST_NOT_NULL","NOT_ATTACHED_TO_FLICKING","WRONG_OPTION","INDEX_OUT_OF_RANGE","POSITION_NOT_REACHABLE","TRANSFORM_NOT_SUPPORTED","STOP_CALLED_BY_USER","ANIMATION_INTERRUPTED","ANIMATION_ALREADY_PLAYING","NOT_ALLOWED_IN_FRAMEWORK","NOT_INITIALIZED","NO_ACTIVE","NOT_ALLOWED_IN_VIRTUAL","MESSAGE","wrongVal","correctTypes","map","type","join","selector","val","name","optionName","min","max","position","EVENTS","READY","BEFORE_RESIZE","AFTER_RESIZE","HOLD_START","HOLD_END","MOVE_START","MOVE","MOVE_END","WILL_CHANGE","CHANGED","WILL_RESTORE","RESTORED","SELECT","NEED_PANEL","VISIBLE_CHANGE","REACH_EDGE","PANEL_CHANGE","ALIGN","PREV","CENTER","NEXT","DIRECTION","NONE","MOVE_TYPE","SNAP","FREE_SCROLL","STRICT","CLASS","VERTICAL","HIDDEN","DEFAULT_VIRTUAL","CIRCULAR_FALLBACK","LINEAR","BOUND","merge","target","_i","sources","forEach","source","Object","keys","key","getElement","el","parent","targetEl","isString","queryResult","document","querySelector","FlickingError","ERROR","nodeType","Node","ELEMENT_NODE","checkExistence","value","nameOnErrMsg","clamp","x","Math","getFlickingAttached","toArray","iterable","slice","call","parseAlign","align","size","alignPoint","parseArithmeticSize","parseBounce","bounce","parsedBounce","Array","isArray","parsedVal","cssValue","base","parsed","parseArithmeticExpression","percentage","absolute","cssRegex","idx","matchResult","exec","sign","unit","parsedValue","parseFloat","signMultiplier","parsePanelAlign","panel","getDirection","start","end","parseElement","element","elements","tempDiv","createElement","innerHTML","push","children","firstChild","removeChild","getMinusCompensatedIndex","includes","array","array_1","__values","circulatePosition","pos","find","checker","array_2","findIndex","length","getProgress","prev","next","getStyle","window","getComputedStyle","currentStyle","setSize","_a","width","height","style","isBetween","circulateIndex","index","range","arr","i","setPrototypeOf","obj","proto","__proto__","message","code","_super","_this","prototype","__extends","Error","_el","_width","_height","_padding","left","right","top","bottom","_isBorderBoxSizing","this","padding","isBorderBoxSizing","newWidth","newHeight","resize","elStyle","clientWidth","clientHeight","paddingLeft","paddingRight","paddingTop","paddingBottom","boxSizing","flicking","isFirstResize","_flicking","_onResize","_enabled","_resizeObserver","viewport","disable","useResizeObserver","ResizeObserver","resizeObserver","_skipFirstResize","observe","addEventListener","disconnect","removeEventListener","_element","_rendered","cameraEl","camera","parentElement","appendChild","_virtualElement","nativeElement","visible","elIndex","_panel","elementIndex","virtual","options","_renderPanel","renderPanel","_initialPanelCount","initialPanelCount","_cache","cache","_panelClass","panelClass","_elements","renderer","panels","uncacheRenderResult","virtualEnabled","externalRenderer","renderExternal","_initVirtualElements","virtualElements","nativeEl","display","count","insert","batchInsert","hasDOMInElements","batchRemove","deleteCount","cameraElement","panelsPerView","fragment","createDocumentFragment","panelEl","className","dataset","toString","EVENT","HOLD","CHANGE","RELEASE","ANIMATION_END","FINISH","POSITION_KEY","_delta","_targetPanel","prevState","ctx","axesEvent","transitTo","delta","prevPosition","newPosition","circularEnabled","lookAt","moveEvent","ComponentEvent","isTrusted","holding","direction","trigger","isCanceled","DISABLED","panelCount","holdStartEvent","HOLDING","animatingContext","control","controller","moveStartEvent","ANIMATING","onChange","State","inputEvent","offset","horizontal","offsetX","offsetY","DRAGGING","flick","setTo","IDLE","_releaseEvent","clickedElement","srcEvent","touch","changedTouches","elementFromPoint","clientX","clientY","clickedPanel","panels_1","contains","cameraPosition","clickedPanelPosition","_moveToChangedPosition","destPos","duration","moveToPosition","updateInput","setActive","activePanel","stop","nextStateType","nextState","IdleState","HoldingState","DraggingState","AnimatingState","DisabledState","onEnter","_state","eventType","externalCtx","currentState","AXES","onHold","onRelease","onAnimationEnd","onFinish","_dragged","e","preventDefault","stopPropagation","_resetInternalValues","_stateMachine","StateMachine","_axes","state","_animatingContext","axes","circular","axis","_panInput","isEnable","get","Axes","deceleration","interruptable","easing","PanInput","inputType","iOSEdgeSwipeThreshold","scale","releaseOnScroll","connect","on","fire","removePreventClickHandler","destroy","enable","controlParams","axm","set","_onAxesHold","_onAxesChange","_preventClickWhenDragged","off","Promise","reject","startPos","targetPanel","resolve","animate","once","newPos","animationFinishHandler","interruptionHandler","_controller","AxesController","_activePanel","animating","init","_progressInPanel","clampToReachablePosition","update","_b","nearestAnchor","findNearestAnchor","removed","canReach","camPos_1","camRangeDiff","rangeDiff","possiblePositions","filter","reduce","nearestPosition","abs","Infinity","_triggerIndexChangeEvent","_animateToPosition","newActivePanel","prevActivePanel","updateAdaptiveHeight","prevIndex","prevPanel","triggeringEvent","event","animateTo","then","render","catch","err","_index","_pos","_count","activeAnchor","findActiveAnchor","anchorAtCamera","snapThreshold","_calcSnapThreshold","posDelta","absPosDelta","snapDelta","targetAnchor","_findSnappedAnchor","threshold","_findAdjacentAnchor","currentPos","clampedPosition","anchorAtPosition","findAnchorIncludePosition","isFinite","anchors","anchorPoints","loopCount","floor","circularIndexOffset","anchorAtPositionIndex","anchor","AnchorPoint","loop","getNextAnchor","getPrevAnchor","isNextDirection","panelSize","alignPos","alignPosition","margin","Control","stopAtEdge","_stopAtEdge","progressInPanel","panelRange","targetPos","_resetIndexRange","cameraRange","currentIndex","prevPanelIndex","nextPanelIndex","nextPanel","prevPos","nextPos","_indexRange","axesRange","indexRange","isOverThreshold","adjacentAnchor","firstAnchor","lastAnchor","shouldBounceToFirst","shouldBounceToLast","includePosition","nearest","panelPos","visibleRange","isVisibleOnRange","firstPanel","getPanel","lastPanel","CameraMode","firstPanelPrev","lastPanelNext","visibleSize","panelSizeSum","every","anchorCount","positionInRange","anchorInRange","possibleAnchors","toggled","toggledPrev","toggleDirection","toggledNext","_calcPanelAreaSum","visibleInCurrentRange","canSee","sum","sizeIncludingMargin","viewportSize","firstPos","lastPos","alignVal","reachablePanels","shouldPrependBoundAnchor","shouldAppendBoundAnchor","indexOffset_1","newAnchors","splice","nearestPanelAtMin","_findNearestPanel","panelAtMin","panelAtMax","prevDist","panelIdx","dist","supportedStyle","documentElement","transformName","transforms_1","prefixedTransform","_transform","_align","_position","_alignPos","_offset","_circularOffset","_circularEnabled","_mode","_range","_visiblePanels","_anchors","NaN","nearestPanel","bounceSize","prevRange","nextRange","nextPosition","viewportEl","firstElementChild","_checkTranslateSupport","_updateMode","_togglePanels","_refreshVisiblePanels","_checkNeedPanel","_checkReachEnd","applyTransform","updateOffset","anchorIdx","activeIndex","getRange","updateCircularToggleDirection","getAnchors","adaptive","unRenderedPanels","rendered","getCircularOffset","_needPanelTriggered","actualPosition","newVisiblePanels","prevVisiblePanels","added","visiblePanels","needPanelTriggered","cameraSize","needPanelThreshold","cameraPrev","cameraNext","wasBetweenRange","isBetweenRange","circularMode","CircularCameraMode","canSetCircularMode","checkAvailability","fallbackMode","circularFallback","BoundCameraMode","LinearCameraMode","bound","toggle","some","isToggled","strategy","_panels","_strategy","panelAlign","_collectPanels","markForShow","_updatePanelSizeByGrid","items","prevFirstPanel","allPanelsInserted","addedPanels","item","insertingIdx","panelsPushed","panelsInserted","_createPanel","_insertPanelElements","increaseIndex","updatePosition","_updateCameraAndControl","moveToPanel","checkPanelContentsReady","allPanelsRemoved","removingIdx","panelsPulled","panelsRemoved","decreaseIndex","_removePanelElements","resetActive","checkingPanels","resizeOnContentsReady","hasContents","contentsReadyChecker","ImReady","loading","prevProgressInPanel","getProgressInPanel","panelBehind","initialized","updateRange","updateAnchors","readyCount","totalCount","check","resetNeedPanelHistory","visibleIndexes","visibles","markForHide","referencePanel","panelSizeObj","firstPanelSizeObj","noPanelStyleOverride","updatePanelSizes","nextSibling","nextSiblingElement","insertBefore","updateRenderingPanels","renderPanels","_resetPanelElementOrder","_removeAllTextNodes","collectPanels","createPanel","reversedElements","getRenderingElementsByOrder","reverse","nextEl","nextElementSibling","childNodes","node","TEXT_NODE","Renderer","elementProvider","_elProvider","_removed","_loading","_resetInternalStates","_size","_margin","_toggled","_toggleDirection","cameraRangeDiff","progress","camPos","disappearPosNext","disappearPosPrev","checkingRange","show","hide","cached","offsetWidth","offsetHeight","marginLeft","marginRight","marginTop","marginBottom","_updateAlignPos","includeMargin","includeRange","moveTo","togglePosition","_togglePosition","prevToggled","camRange","camAlignPosition","camVisibleRange","camVisibleSize","minimumVisible","maximumVisible","shouldBeVisibleAtMin","shouldBeVisibleAtMax","providerCtor","_providerCtor","renderedPanels","__spread","getRenderingIndexesByOrder","renderOnlyVisible","_showOnlyVisiblePanels","Panel","_cachedInnerHTML","virtualElCount","result","newInnerHTML","cacheRenderResult","virtualManager","invisibleIndexes","sort","panel1","panel2","_","VirtualPanel","VirtualElementProvider","root","_c","_d","defaultIndex","_e","_f","_g","_h","_j","_k","_l","_m","_o","_p","preventEventsBeforeInit","_q","_r","_s","pow","_t","_u","moveType","_v","_w","_x","_y","_z","preventClickOnDrag","_0","disableOnInit","_1","_2","_3","autoInit","_4","autoResize","_5","_6","_7","_initialized","_plugins","_defaultIndex","_horizontal","_circular","_circularFallback","_bound","_adaptive","_panelsPerView","_noPanelStyleOverride","_resizeOnContentsReady","_virtual","_needPanelThreshold","_preventEventsBeforeInit","_deceleration","_duration","_easing","_inputType","_moveType","_threshold","_interruptable","_bounce","_iOSEdgeSwipeThreshold","_preventClickOnDrag","_disableOnInit","_renderOnlyVisible","_autoInit","_autoResize","_useResizeObserver","_externalRenderer","_renderExternal","_viewport","Viewport","_autoResizer","AutoResizer","_renderer","_createRenderer","_camera","_createCamera","_control","_createControl","_virtualManager","VirtualManager","addPreventClickHandler","originalTrigger","_moveToInitialPanel","disableInput","plugin","includePanelHTML","visiblePanelsOnly","status","panelInfo","html","outerHTML","visibleOffset","panelIndex","newCameraPos","plugins","foundIndex","prevWidth","prevHeight","forceRenderAllPanels","updatePanelSize","updateAlignPos","sizeChanged","moveTypes","moveTypeStr","moveTypeOptions","JSON","stringify","SnapControl","FreeControl","StrictControl","console","warn","Camera","_createExternalRenderer","_createVanillaRenderer","rendererOptions","VanillaRenderer","VirtualRenderingStrategy","NormalRenderingStrategy","VanillaElementProvider","initialPanel","Flicking","Component","diffResult","addedElements","startIdx","endIdx","elIdx","getCameraAlign","getPanelAlign","flickingName","getOwnPropertyNames","startsWith","descriptor","getOwnPropertyDescriptor","defineProperty","args","getterDescriptor","prevList","endIdx_1","prevIdx_1","removedIdx","ordered","__read","prevIdx","newIdx","indexDiff","middlePanels","startIdx_1","prevIdx_2","addedElements_1","addedIdx","removedPanels","maintainedMap","maintained","current","list","firstPanelSize","cameraAlign","camPosition","Constants","CFC","Utils"],"mappings":"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"}